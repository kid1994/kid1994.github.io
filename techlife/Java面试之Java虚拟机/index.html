<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="剑知的博客.">
    <meta name="keyword"  content="剑知">
    <link rel="shortcut icon" href="/assets/blogImg/me.jpg">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          Java面试之Java虚拟机 - 剑知
        
    </title>

    <link rel="canonical" href="http://kid1994.github.io/techlife/Java面试之Java虚拟机/">

    <!-- Bootstrap Core CSS -->

   <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/3.4.1/css/bootstrap.min.css">



    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/beantech.min.css">

    <link rel="stylesheet" href="/css/donate.css">
	<link rel="stylesheet" href="/css/w3.css">
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->


    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
    }
   .post-heading{
    padding:20px;
    }
  .person {
    border: 10px solid transparent;
    margin-bottom: 25px;
    width: 80%;
    height: 80%;
    opacity: 0.7;
  }
  .person:hover {
    border-color: #f1f1f1;
  }

</style>

<header id="headerid" class="w3-indigo intro-header" style="position:relative;">
    <!-- Signature -->
	
        <div class="container">
            <div class=" row" >
			
			<canvas id="particles-js-canvas" style="position:absolute;z-index:1;top:0px;left:0px;" width="100%" height="50%"></canvas>
			
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1" style="z-index:2;">
                
                    <div class="post-heading" style="padding:40px">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#Java" title="Java">Java</a>
                            
                              <a class="tag" href="/tags/#面试" title="面试">面试</a>
                            
                        </div>
                        <h1>Java面试之Java虚拟机</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by 剑知 on
                            2018-04-05
                        </span>
                    </div>
                
                </div>
            </div>
        </div>
  
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">剑知</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a  href="/">主页</a>
                    </li>
		    
                    

                        
                        <li>
           
                            <a  href="/技术人生">技术人生</a>
                           
                        </li>
                        
                    

                        
                        <li>
           
                            <a  href="/拿破轮">拿破轮</a>
                           
                        </li>
                        
                    

                        
                        <li>
           
                            <a  href="/我的梦呓">我的梦呓</a>
                           
                        </li>
                        
                    

                        
                        <li>
           
                            <a  href="/好奇心">好奇心</a>
                           
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <p>这是Java面试复习点的Java虚拟机部分。</p>
<p>面经只是一种方法，一种手段，而不是目的，最终要能够自己将点织成线，将线编成面，将面合成体。</p>
<a id="more"></a>
<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
<ul>
<li><a href="#你了解java内存模型么">你了解Java内存模型么？</a></li>
<li><a href="#jvm内存区域分为哪几块分别如何使用">JVM内存区域分为哪几块？分别如何使用？</a></li>
<li><a href="#直接内存是什么">直接内存是什么？</a></li>
<li><a href="#jvm内存区域会出现哪几种异常分别可以在哪块区域出现出现的条件是什么">JVM内存区域会出现哪几种异常？分别可以在哪块区域出现？出现的条件是什么？</a></li>
<li><a href="#堆和栈有什么区别可以从哪些方面进行比较">堆和栈有什么区别？可以从哪些方面进行比较？</a></li>
<li><a href="#jvm堆内存的结构是怎样的各个结构存放的是哪种对象对象如何在各个结构之间迁移">JVM堆内存的结构是怎样的？各个结构存放的是哪种对象？对象如何在各个结构之间迁移？</a></li>
<li><a href="#垃圾收集算法有哪些各个算法是如何操作的各自有什么特点效率问题空间问题">垃圾收集算法有哪些？各个算法是如何操作的？各自有什么特点？效率问题？空间问题？</a></li>
<li><a href="#当前商业虚拟机一般使用的是哪种垃圾收集算法">当前商业虚拟机一般使用的是哪种垃圾收集算法？</a></li>
<li><a href="#堆内存的各个结构分别使用哪种垃圾收集算法">堆内存的各个结构分别使用哪种垃圾收集算法？</a></li>
<li><a href="#jvm中为什么会有gc停顿">JVM中为什么会有GC停顿？</a></li>
<li><a href="#内存溢出和内存泄露的概念分别是什么有什么区别能否分别举几个例子">内存溢出和内存泄露的概念分别是什么？有什么区别？能否分别举几个例子？</a></li>
<li><a href="#如何判断对象是否还活着简单描述各个算法">如何判断对象是否还活着？简单描述各个算法？</a></li>
<li><a href="#如何分析和定位内存泄露">如何分析和定位内存泄露？</a></li>
<li><a href="#可达性算法分析中哪些对象可以作为gc-roots这些对象有什么特点">可达性算法分析中，哪些对象可以作为GC roots？这些对象有什么特点？</a></li>
<li><a href="#full-gc的触发条件有哪三个">full GC的触发条件有哪三个？</a></li>
<li><a href="#垃圾收集器的职责是什么">垃圾收集器的职责是什么？</a></li>
<li><a href="#什么时候运行垃圾回收什么是安全点什么是安全区域">什么时候运行垃圾回收？什么是安全点？什么是安全区域？</a></li>
<li><a href="#jvm是如何加载class文件的">JVM是如何加载class文件的？</a></li>
<li><a href="#jvm加载class文件有哪几个过程每个过程分别主要干了什么">JVM加载class文件有哪几个过程？每个过程分别主要干了什么？</a></li>
<li><a href="#类加载过程采用了什么机制描述一下这种机制">类加载过程采用了什么机制？描述一下这种机制？</a></li>
<li><a href="#java中的引用有哪几种类型所引用的对象分别在什么情况在会被回收">Java中的引用有哪几种类型？所引用的对象分别在什么情况在会被回收？</a></li>
<li><a href="#新生代和老年代分别有哪些垃圾收集器各自有什么特点画出那张图">新生代和老年代分别有哪些垃圾收集器？各自有什么特点？画出那张图？</a></li>
<li><a href="#每种垃圾收集器的运行过程和特点是什么">每种垃圾收集器的运行过程和特点是什么？</a></li>
<li><a href="#知道哪些jvm的命令行工具是否都用过怎么用">知道哪些JVM的命令行工具？是否都用过？怎么用？</a></li>
<li><a href="#是否了解class文件的格式是否能够阅读class文件">是否了解class文件的格式？是否能够阅读class文件？</a></li>
<li><a href="#jvm监控和调优的一般步骤是什么">JVM监控和调优的一般步骤是什么？</a></li>
<li><a href="#经常遇到的内存异常有哪些如何定位和解决这些异常">经常遇到的内存异常有哪些？如何定位和解决这些异常？</a></li>
<li><a href="#是否知道jvm的标准非标准和非stable参数">是否知道JVM的标准、非标准和非stable参数？</a></li>
</ul>
<!-- /TOC -->
<h1 id="你了解Java内存模型么？"><a href="#你了解Java内存模型么？" class="headerlink" title="你了解Java内存模型么？"></a>你了解Java内存模型么？</h1><p>答：Java内存模型规范了java虚拟机和计算机内存如何协同工作，规定了如何及何时能看到其它线程修改的共享变量的值，以及在必要时如何同步访问共享变量。<br>Java内存模型把java虚拟机内部划分为线程栈和堆：<br><img src="/techlife/Java面试之Java虚拟机/1.jpg" alt=""></p>
<p><a href="http://www.importnew.com/19612.html" target="_blank" rel="noopener">参考</a></p>
<h1 id="JVM内存区域分为哪几块？分别如何使用？"><a href="#JVM内存区域分为哪几块？分别如何使用？" class="headerlink" title="JVM内存区域分为哪几块？分别如何使用？"></a>JVM内存区域分为哪几块？分别如何使用？</h1><p>答：JVM内存区域分为堆、线程方法栈、本地方法栈、方法区（静态区）和程序计数器。<br>通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在静态区中。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上的虚拟内存都可以被当成堆空间来使用。<br><code>String str = new String(&quot;hello&quot;);</code><br>上面的语句中变量str放在栈上，。用new创建出来的字符串对象放在堆上，而”hello”这个字面量放在静态区。<br>补充：较新版本的Java（从Java 6的某个更新开始）中使用了一项叫”逃逸分析”的技术，可以将一些局部对象放在栈上以提升对象的操作性能。</p>
<h1 id="直接内存是什么？"><a href="#直接内存是什么？" class="headerlink" title="直接内存是什么？"></a>直接内存是什么？</h1><p>答：直接内存不属于JVM运行时数据区的一部分，它是在NIO类中引入一种基于通道和缓冲区的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。<br>直接内存的分配不会受到Java堆大小的限制，但是会受到本机内存大小的限制，所以也有可能抛出OutOfMemoryError异常。</p>
<h1 id="JVM内存区域会出现哪几种异常？分别可以在哪块区域出现？出现的条件是什么？"><a href="#JVM内存区域会出现哪几种异常？分别可以在哪块区域出现？出现的条件是什么？" class="headerlink" title="JVM内存区域会出现哪几种异常？分别可以在哪块区域出现？出现的条件是什么？"></a>JVM内存区域会出现哪几种异常？分别可以在哪块区域出现？出现的条件是什么？</h1><p>答：</p>
<ol>
<li>程序计数器。此区域是唯一一个在Java虚拟机中没有规定任何OutOfMemory情况的区域。</li>
<li>Java虚拟机栈。如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。如果虚拟机动态扩展的时候没有申请到足够的内存则会抛出OutOfMemory异常。</li>
<li>本地方法栈。与Java虚拟机栈一样，本区域也是会抛出StackOverflowStack和OutOfMemory两种异常。</li>
<li>Java堆。如果堆中的内存不够为实例分配内存并且也扩展失败了，就会抛出OutOfMemory异常。</li>
<li>方法区。当方法区无法满足内存分配需求时，将抛出OutOfMemory异常。</li>
</ol>
<h1 id="堆和栈有什么区别？可以从哪些方面进行比较？"><a href="#堆和栈有什么区别？可以从哪些方面进行比较？" class="headerlink" title="堆和栈有什么区别？可以从哪些方面进行比较？"></a>堆和栈有什么区别？可以从哪些方面进行比较？</h1><p>答：</p>
<ol>
<li>栈中存放的是基本数据类型和引用变量，为执行java方法服务。堆中存放的是所有的对象和数组实例。（存放的内容不同）</li>
<li>栈是线程私有的，描述的是方法执行的内存模型；堆是线程共享的。（是否是线程共享）</li>
<li>栈主要是用来执行程序的，堆主要用来存放对象的。（用途不同）</li>
<li>栈相对于堆来说，栈的存取速度更快，但栈的大小和生存期必须是确定的，因此缺乏一定的灵活性。但堆却可以在运行时动态地分配内存，生存期不需要提前告诉编译器，但这也导致了其存取速度的缓慢。（速度和生命周期不同）。</li>
</ol>
<h1 id="JVM堆内存的结构是怎样的？各个结构存放的是哪种对象？对象如何在各个结构之间迁移？"><a href="#JVM堆内存的结构是怎样的？各个结构存放的是哪种对象？对象如何在各个结构之间迁移？" class="headerlink" title="JVM堆内存的结构是怎样的？各个结构存放的是哪种对象？对象如何在各个结构之间迁移？"></a>JVM堆内存的结构是怎样的？各个结构存放的是哪种对象？对象如何在各个结构之间迁移？</h1><p>答：Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，此内存的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
<p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为是”GC”堆。从内存分配的角度看，线程共享的Java堆可能划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer,TLAB)。从内存回收的角度来看，由于现在收集器基本都采用分代收集，所以Java堆还可以细分为：新生代和老年代；再细致一点新生代可以分为Eden空间、From Survivor空间、To Survivor空间等。不过无论如何划分，都与存放的内容无关，无论哪个区域，存放的都仍然是对象实例。进一步划分的目的是为了更好地回收和分配内存。</p>
<p>新生代采用复制的方式收集内存，将内存分为一块较大的Eden区和两个较小的Survivor区。新建对象总是在Eden区，当Eden区已满，就触发一次young GC，将还存活的对象复制到From Survivor空间。这样Eden区都是未被使用的空间，可供继续创建对象，当Eden区再次被使用满，就会触发一次young GC，当回收时，将Eden区和Survivor区中还存活的对象一次性地复制到另外一个Survivor区上。后面就是每次使用Eden区和一个survivor区，当回收时，将Eden区和Survivor区中还存活的对象一次性地复制到另外一个Survivor区上。如果超过某个阈值对象还未被释放，则将该对象复制到老年代。<br>Eden区存新分配内存的对象，Survivor区存至少经历了一次垃圾回收，并得以幸存的对象。</p>
<p>老年代则存放年长的对象(存在时间较长，经过垃圾回收次数较多的对象)。</p>
<h1 id="垃圾收集算法有哪些？各个算法是如何操作的？各自有什么特点？效率问题？空间问题？"><a href="#垃圾收集算法有哪些？各个算法是如何操作的？各自有什么特点？效率问题？空间问题？" class="headerlink" title="垃圾收集算法有哪些？各个算法是如何操作的？各自有什么特点？效率问题？空间问题？"></a>垃圾收集算法有哪些？各个算法是如何操作的？各自有什么特点？效率问题？空间问题？</h1><p>答：<br>1.标记-清除算法<br>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。<br>主要的不足：①效率问题：标记和清除的效率都不高；②空间问题：标记清除后，空间内会有大量不连续的内存碎片，空间碎片太多会导致以后在程序运行过程中需要分配较大对象时，无法找到足够大的内存而不得不提前触发一次垃圾回收操作。</p>
<p>2.复制算法<br>将可用的内存按容量大小分为两块大小相等的两块，每次只使用其中的一块。当某一块的内存使用完了，就把还存活的对象移到另一块内存上，然后把当前这块做清理掉。<br>优点：实现简单，运行高效。<br>缺点：代价太大，将原来的内存缩小为原来的一半。</p>
<p>3.标记-整理算法<br>标记过程与”标记-清除算法“一样，但是后续步骤不是直接对可回收的对象进行清理，而是把所有存活的对象都移到一端，然后直接清理掉端边界以外的内存。</p>
<p>4.分代收集算法<br>当前商业虚拟机的垃圾收集都采用”分代收集”(Generational Collection)，根据对象存活周期的不同将内存划分为几块。一般是把堆分为新生代和老年代，在新生代采用复制算法回收内存，老年代采用标记-整理或标记-清除算法。算法在运行的过程中优先收集处于新生代的对象，如果一个对象经过多次收集还存活，那么就可以把这个对象移到高一级的堆里，减少对其扫描的次数。</p>
<h1 id="当前商业虚拟机一般使用的是哪种垃圾收集算法？"><a href="#当前商业虚拟机一般使用的是哪种垃圾收集算法？" class="headerlink" title="当前商业虚拟机一般使用的是哪种垃圾收集算法？"></a>当前商业虚拟机一般使用的是哪种垃圾收集算法？</h1><p>答：分代收集算法。</p>
<h1 id="堆内存的各个结构分别使用哪种垃圾收集算法？"><a href="#堆内存的各个结构分别使用哪种垃圾收集算法？" class="headerlink" title="堆内存的各个结构分别使用哪种垃圾收集算法？"></a>堆内存的各个结构分别使用哪种垃圾收集算法？</h1><p>答：年轻代使用复制算法，老年代使用标记-整理或标记-清除算法。</p>
<h1 id="JVM中为什么会有GC停顿？"><a href="#JVM中为什么会有GC停顿？" class="headerlink" title="JVM中为什么会有GC停顿？"></a>JVM中为什么会有GC停顿？</h1><p>答：判断对象是否存活的可达性分析对时间的敏感还体现在GC停顿上，因为可达性分析工作必须在一个能确保一致性的快照中进行，这里的“一致性”的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况。不然的话可达性分析的结果就无法得到保证，这是导致GC进行时必须停顿所有Java执行线程的一个重要原因。</p>
<h1 id="内存溢出和内存泄露的概念分别是什么？有什么区别？能否分别举几个例子？"><a href="#内存溢出和内存泄露的概念分别是什么？有什么区别？能否分别举几个例子？" class="headerlink" title="内存溢出和内存泄露的概念分别是什么？有什么区别？能否分别举几个例子？"></a>内存溢出和内存泄露的概念分别是什么？有什么区别？能否分别举几个例子？</h1><p>答：内存泄露是指一个不再被程序使用的对象或变量还在内存中占用空间。在java语言中，判断一个内存空间是否符合垃圾回收的标准有两个：第一，给对象赋予了空值null，以后再也没有不会被使用；第二，给对象赋予了新值，重新分配了内存空间。</p>
<p>一般来说，内存泄露主要有两种情况：</p>
<ol>
<li>在堆中申请的空间没有被释放；</li>
<li>对象已不再使用但是还仍然在内存中保留着。<br>垃圾回收机制的引入可以有效地解决第一种情况，但是对第二种情况却没有办法解决，因此java语言中内存泄露主要指的是第二种情况。</li>
</ol>
<p>在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。</p>
<p>在Java语言中，容易引起内存泄露的原因有很多，主要可以分为以下几种。</p>
<ol>
<li>静态集合类。例如HashMap和Vector，如果这些容器是静态的，那么它们的声明周期与程序一样，在程序结束之前这些容器所占的空间将得不到释放，从而造成内存泄露；</li>
<li>各种连接。比如Connection、Statement、ResultSet等如果使用之后不显示地关闭，会造成大量的对象无法回收，造成内存泄露；</li>
<li>监听器。在java中，往往一个程序使用多个监听器，但是在释放对象的时候却没有删除相应的监听器对象就会导致内存泄露；</li>
<li>变量不合理的作用域。如果一个变量定义的作用范围大于其使用范围，就有可能造成内存泄露，另一个方面如果没有及时地把一个对象设置为null，也有可能导致内存泄露；</li>
<li>单例模式可能会造成内存泄露。如果以静态的方式存储单例对象的话，那么它在JVM的整个生命周期中都存在，就会导致内存泄露。</li>
</ol>
<p>内存溢出是指程序要求的内存，超出了系统所能分配的范围，从而发生溢出。<br>内存泄露的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.EmptyStackException;</span><br><span class="line">public class MyStack&lt;T&gt; &#123;</span><br><span class="line">    private T[] elements;</span><br><span class="line">    private int size = 0;</span><br><span class="line">    private static final int INIT_CAPACITY = 16;</span><br><span class="line">    public MyStack() &#123;</span><br><span class="line">        elements = (T[]) new Object[INIT_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(T elem) &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = elem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T pop() &#123;</span><br><span class="line">        if(size == 0)</span><br><span class="line">            throw new EmptyStackException();</span><br><span class="line">        return elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ensureCapacity() &#123;</span><br><span class="line">        if(elements.length == size) &#123;</span><br><span class="line">            elements = Arrays.copyOf(elements, 2 * size + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的pop方法却存在内存泄露的问题，当我们用pop方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成OutOfMemoryError。</p>
<h1 id="如何判断对象是否还活着？简单描述各个算法？"><a href="#如何判断对象是否还活着？简单描述各个算法？" class="headerlink" title="如何判断对象是否还活着？简单描述各个算法？"></a>如何判断对象是否还活着？简单描述各个算法？</h1><p>答：主要有引用计数法和可达性分析两种方法来判断对象是否还在存活。《深入理解Java虚拟机》P64<br>1.引用计数法<br>每个对象都有一个引用计数器，每当该对象被引用时则计数器加1，当某个引用失效时，则引用计数器减1。任何时刻引用计数器的值为0的对象就是不可能再被引用的。<br>缺点是无法解决循环引用的问题，现在主流的java虚拟机没有采用引用计数法来管理内存。</p>
<p>2.可达性分析算法<br>通过一系列称为”GC Roots“的对象作为起始点，从这些节点开始向下搜索与其相连的对象，搜索过程中经过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链时，则证明该对象是不可用的。</p>
<p>在主流的商用程序语言(Java C#)的主流实现中，都是通过可达性分析算法来判定对象是否存活的。</p>
<p>在可达性分析算法中不可达的对象，也并非是”非死不可的“，要真正宣告一个对象是否死亡，需要经历两次被标记过程。第一次标记判断是否有必要执行finalize()方法，将有必要执行的对象放到F-Queue的队列之中；稍后GC会对F-Queue进行第二次标记，finalize()方法是对象逃脱死亡命运的最后一次机会，如果对象在finalize()方法中成功地与引用链上的任何一个对象相关联，那么在第二次标记时会把这个对象彻底移除”即将回收“的集合。</p>
<p>finalize()方法是Object类的一个方法，在垃圾回收器执行时会调用被回收对象的finalize()方法，可以覆盖此方法来实现对其他资源的回收，比如关闭文件等。需要注意的是，一旦垃圾回收器准备好释放对象占用的空间时，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。</p>
<h1 id="如何分析和定位内存泄露？"><a href="#如何分析和定位内存泄露？" class="headerlink" title="如何分析和定位内存泄露？"></a>如何分析和定位内存泄露？</h1><p>答：一般步骤：</p>
<ul>
<li>把Java应用程序使用的heap dump下来</li>
<li>使用Java heap分析工具，找出内存占用超出预期（一般是因为数量太多）的嫌疑对象</li>
<li>必要时，需要分析嫌疑对象和其他对象的引用关系。</li>
<li>查看程序的源代码，找出嫌疑对象数量过多的原因<br><a href="https://blog.csdn.net/bigtree_3721/article/details/50550248" target="_blank" rel="noopener">参考</a></li>
</ul>
<h1 id="可达性算法分析中，哪些对象可以作为GC-roots？这些对象有什么特点？"><a href="#可达性算法分析中，哪些对象可以作为GC-roots？这些对象有什么特点？" class="headerlink" title="可达性算法分析中，哪些对象可以作为GC roots？这些对象有什么特点？"></a>可达性算法分析中，哪些对象可以作为GC roots？这些对象有什么特点？</h1><p>答：在Java语言中，可作为GC Roots的对象主要包括以下四个方面。</p>
<ol>
<li>虚拟机栈中的引用对象；</li>
<li>本地方法栈中本地方法引用的对象；</li>
<li>方法区中类静态属性引用的对象；</li>
<li>方法区内常量引用的对象。<br>都是栈或方法区中引用的对象。</li>
</ol>
<h1 id="full-GC的触发条件有哪三个？"><a href="#full-GC的触发条件有哪三个？" class="headerlink" title="full GC的触发条件有哪三个？"></a>full GC的触发条件有哪三个？</h1><h1 id="垃圾收集器的职责是什么？"><a href="#垃圾收集器的职责是什么？" class="headerlink" title="垃圾收集器的职责是什么？"></a>垃圾收集器的职责是什么？</h1><h1 id="什么时候运行垃圾回收？什么是安全点？什么是安全区域？"><a href="#什么时候运行垃圾回收？什么是安全点？什么是安全区域？" class="headerlink" title="什么时候运行垃圾回收？什么是安全点？什么是安全区域？"></a>什么时候运行垃圾回收？什么是安全点？什么是安全区域？</h1><h1 id="JVM是如何加载class文件的？"><a href="#JVM是如何加载class文件的？" class="headerlink" title="JVM是如何加载class文件的？"></a>JVM是如何加载class文件的？</h1><p>答：类加载机制就是把class文件变成虚拟机可以直接使用的java类型的过程。具体过程是从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</p>
<h1 id="JVM加载class文件有哪几个过程？每个过程分别主要干了什么？"><a href="#JVM加载class文件有哪几个过程？每个过程分别主要干了什么？" class="headerlink" title="JVM加载class文件有哪几个过程？每个过程分别主要干了什么？"></a>JVM加载class文件有哪几个过程？每个过程分别主要干了什么？</h1><p>答：类从被加载到虚拟机内存中开始，到卸载出内存位置，整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载。<br>其中类加载过程包括加载、链接、初始化。<br>1.加载.由类加载器完成，做的事情有3个：</p>
<ul>
<li>根据权限定名获取此类的二进制字节流；</li>
<li>将这个字节流代表的静态存储结构转化为方法区的运行时数据结构；</li>
<li>在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
<p>2.验证。检查待加载的class文件的正确性，目的是为了确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。格式检查（是否是class文件、）元数据检查（是否继承了final的类，是否实现了接口中的所有方法）符号引用验证（访问性 private protected）</p>
<p>3.准备。在方法区内为类中的静态变量分配存储空间。<br>准备阶段是正式为类变量(被static修饰的变量)分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中分配。</p>
<p>4.解析。将虚拟机常量池中的符号引用替换为直接引用的过程。<br>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时可以无歧义地定位到目标即可。符号引用和虚拟机实现的内存布局无关。<br>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存布局有关。</p>
<p>5.初始化。如果该类具有超类，则对其初始化，执行静态初始化变量和静态初始化代码块。</p>
<h1 id="类加载过程采用了什么机制？描述一下这种机制？"><a href="#类加载过程采用了什么机制？描述一下这种机制？" class="headerlink" title="类加载过程采用了什么机制？描述一下这种机制？"></a>类加载过程采用了什么机制？描述一下这种机制？</h1><p>答：双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是会把这个加载的请求委派给父类加载器去完成，每一个层次的类加载器都是这么做，只有当父类加载器无法完成类的加载工作时，子类加载器才会尝试自己去加载这个类。</p>
<p>使用双亲委派模型来组织类加载器之间的关系的一个好处是就是Java类随着它的加载器一起具备了一种带有优先级的层次关系，保证了java程序的稳定性。</p>
<p>注意：在深入理解Java虚拟机P231中提到，在双亲委派模型中的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的代码。<br>从Java虚拟机的角度看，只存在两种不同的类加载器：</p>
<ol>
<li>启动类加载器，C++语言实现，是虚拟机自身的一部分；</li>
<li>所有的其他的类加载器，Java语言实现，独立于虚拟机外部，并且全部都继承自抽象类java.lang.ClassLoader.</li>
</ol>
<p>从Java开发人员的角度来看，类加载器可以划分为启动类加载器、扩展类加载器和应用程序类加载器。</p>
<p>1.启动类加载器(Bootstrap ClassLoader)：这个类主要负责将存放在&lt;JAVA_HOME&gt;\lib目录中的，或者被-Xbootclasspath参数所指定的路径中，并且可以被虚拟机识别的(如rt.jar)类库加载到虚拟机内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。</p>
<p>2.标准扩展(Extension)类加载器：是由Sun的ExtClassLoader (sun.misc.Launcher$ExtClassLoader)实现的，它负责将&lt;JAVA_HOME&gt;\lib\ext或者由系统变量java.ext.dirs指定位置中的类库加载到内存中，开发者可以直接使用标准扩展类加载器。</p>
<p>3.应用程序类加载器(Application ClassLoader)：这个类加载器由sun.misc.Launcher $ApplicationClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也被称作是系统类加载器。它负责加载用户类路径(ClassPath)上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<h1 id="Java中的引用有哪几种类型？所引用的对象分别在什么情况在会被回收？"><a href="#Java中的引用有哪几种类型？所引用的对象分别在什么情况在会被回收？" class="headerlink" title="Java中的引用有哪几种类型？所引用的对象分别在什么情况在会被回收？"></a>Java中的引用有哪几种类型？所引用的对象分别在什么情况在会被回收？</h1><p>答：</p>
<ol>
<li>强引用：如果一个对象具有强引用，那垃圾回收器当内存不够时，宁愿抛出outofmemory错误也不会程序终止,类似于Object obj = new Object().</li>
<li>软引用：如果一个对象具有软引用，如内存空间足够，垃圾回收器就不会回收它，如果内存不足，就会回收这些对象的内存（可以实现内存敏感的高速缓存，软引用可以和一个引用队列（ReferenceQueue）联合使用）。Soft Reference的主要特点是据有较强的引用功能。只有当内存不够的时候，才进行回收这类内存，因此在内存足够的时候，它们通常不被回收。另外，这些引用对象还能保证在Java抛出OutOfMemory 异常之前，被设置为null。它可以用于实现一些常用图片的缓存，实现Cache的功能，保证最大限度的使用内存而不引起OutOfMemory。</li>
<li>弱引用：在系统GC时，只要发现弱引用，不管堆空间是否足够，都会讲对象进行回收。</li>
<li>虚引用：随时都有可能被垃圾回收器回收。就是一旦有gc扫过它就会清除对象空间。作用在于跟踪垃圾回收过程，清理被销毁对象的相关资源。无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li>
</ol>
<h1 id="新生代和老年代分别有哪些垃圾收集器？各自有什么特点？画出那张图？"><a href="#新生代和老年代分别有哪些垃圾收集器？各自有什么特点？画出那张图？" class="headerlink" title="新生代和老年代分别有哪些垃圾收集器？各自有什么特点？画出那张图？"></a>新生代和老年代分别有哪些垃圾收集器？各自有什么特点？画出那张图？</h1><p>答：<br><img src="/techlife/Java面试之Java虚拟机/2.jpg" alt=""><br>1.Serial收集器：一个单线程的收集器，但它“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作。更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程。新生代收集器、采用复制算法。<br>    优点：与其他收集器的单线程比，简单而高效。<br>Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。</p>
<p>2.ParNew收集器：其实就是Serival收集器的多线程版本。新生代收集器、采用复制算法。适用于运行在server模式下的虚拟机中首选的新生代收集器。</p>
<p>3.Parallel Scavenge收集器：新生代收集器、采用复制算法、并行的多线程收集。主要适合在后台运算而不需要太多交互的任务，注重的是吞吐量。如果用户对于收集器运作不是很了解，手工优化困难的时候，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调节任务交给虚拟机去完成将是一个不错的选择。<br>自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个不同。</p>
<p>4.SerialOld收集器：是Serial的老年代版本，同样是一个单线程收集器，使用“标记-整理”算法。主要给在Client模式下的虚拟机使用。如果是在Server模式下则主要有两大用途，一是在JDK1.5以及之前的版本中与Parallel Scavenge 收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p>
<p>5.Parallel Old收集器：是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge收集器和Parallel Old收集器。</p>
<p>6.CMS(Conourrent Mark Sweep )收集器：以获取最短回收停顿时间为目标的收集器。基于”标记-清除”算法实现。<br>整个过程分为四步：初始标记、并发标记、重新标记、并发清除。<br>优点：并发收集、低停顿。<br>缺点：对CPU资源敏感；无法处理浮动垃圾；收集结束会有大量碎片。</p>
<p>7.G1收集器：面向服务端应用的垃圾收集器，标记整理。与其他GC收集器相比：G1具有如下特点：并发与并行；分代收集；空间整合；可预测的停顿。<br>运作的过程大致分为四个步骤：初始标记；并发标记；最终标记；筛选回收。<br>备注：并发(Parallel):指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；并行(Concurrent):指用户线程与垃圾收集线程同时执行(但不一定是并行的，可能会交替执行 )，用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</p>
<h1 id="每种垃圾收集器的运行过程和特点是什么？"><a href="#每种垃圾收集器的运行过程和特点是什么？" class="headerlink" title="每种垃圾收集器的运行过程和特点是什么？"></a>每种垃圾收集器的运行过程和特点是什么？</h1><p>答：参考：深入理解Java虚拟机3.4节。</p>
<h1 id="知道哪些JVM的命令行工具？是否都用过？怎么用？"><a href="#知道哪些JVM的命令行工具？是否都用过？怎么用？" class="headerlink" title="知道哪些JVM的命令行工具？是否都用过？怎么用？"></a>知道哪些JVM的命令行工具？是否都用过？怎么用？</h1><p>答：<br>1.jps：虚拟机进程状况工具；<br>只运行jps输出的是当前运行的java进程(Java程序的进程ID，Main函数)；<br>运行jps –q只输出进程ID，而不输出类的名称；<br>jps –m输出传递给Java进程(主函数)的短名称；<br>jps –l输出主函数的完整路径；<br>jps –v输出传递给JVM的参数。</p>
<p>2.jstat：虚拟机统计信息监视工具；可以用于观察Java应用程序运行时信息的工具。<br>jstat可以实时显示本地或远程JVM进程中类装载、内存、垃圾收集、JIT编译等数据（如果要显示远程JVM信息，需要远程主机开启RMI支持）。如果在服务启动时没有指定启动参数-verbose:gc，则可以用jstat实时查看gc情况。<br>在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，jstat是运行期定位虚拟性能问题的首选工具。<br>如jstat –gc 2764 250 20表示查询进程2764垃圾收集状况，每250ms查询一次，一共查询20次。后面两个参数省略时表示只查询一次。<br>命令格式为jstat option vmid interval count.<br>其中option主要分为3类：类装载、垃圾收集、运行期编译。<br>-class    监视类装载、卸载数量、总空间以及类装载耗费的时间。<br>-gc    监视java堆状况，包括Eden区、两个survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息。<br>-gccapacity    监视内容与-gc相同，但输出主要关注Java堆各个区域使用到的最大、最小空间<br>-gcutil    监视内容与-gc相同，但输出主要关注已经使用的空间占总空间的百分比<br>-gnew    监视新生代GC状态<br>-gold    监视老年代GC状态<br>-gcompiler    输出JIT编译器编译过的方法、耗时等信息。</p>
<p>3.jinfo：Java配置信息工具；用于查询当前运行时的JVM属性和参数的值。<br>jinfo可以使用如下选项：<br>   -flag:显示未被显示指定的参数的系统默认值<br>   -flag [+|-]name或-flag name=value: 修改部分参数<br>   -sysprops:打印虚拟机进程的System.getProperties()<br> 命令格式:jinfo [option] pid</p>
<p>4.jmap：java内存映像工具；<br>用于显示当前Java堆和永久代的详细信息（如当前使用的收集器，当前的空间使用率等）.<br>        jmap –heap:显示java堆的相信信息，如使用哪种收集器、参数配置、分代状态等。<br>        Jmap-dump:生成java堆转储快照。</p>
<p>5.jhat：虚拟机堆转储快照分析工具；<br>用于分析使用jmap生成的dump文件，是JDK自带的工具，使用方法为： jhat -J -Xmx512m [file]</p>
<p>6.jstack：java堆栈跟踪工具；<br>用于生成当前JVM的所有线程快照，线程快照是虚拟机每一条线程正在执行的方法,目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情或者是在等待什么资源。<br>   -F:当正常输出的请求不被响应时，强制输出线程堆栈<br>   -l:除堆栈外，显示关于锁的附加信息<br>   -m:如果调用到本地方法的话，可以显示C/C++的堆栈<br>命令格式:jstack [option] vmid<br>例如jstack –l 3500会显示3500编号的进程的带有锁信息的堆栈信息。</p>
<p>7.HSDIS：JIT生成代码反汇编。</p>
<p>8.JConsole<br>    JConsole工具是JDK自带的图形化性能监控工具。通过JConsole工具，可以查看Java应用程序的运行概况，监控堆信息、永久区使用情况、类加载情况。<br>在JConsole中可以查看堆的详细信息，包括堆的大小、使用率、eden区大小、survivor区大小、永久区大小。<br>JConsole可以方便地查看系统内的线程信息，并且可以快速定位死锁问题。<br>    JConsole的类页面可以显示系统已经装载的类数量。<br>JConsole的VM摘要显示了当前Java应用程序的基本信息，如虚拟机类型、虚拟机版本、系统线程信息、操作系统内存信息、堆信息、垃圾回收器信息以及路径信息等。</p>
<h1 id="是否了解class文件的格式？是否能够阅读class文件？"><a href="#是否了解class文件的格式？是否能够阅读class文件？" class="headerlink" title="是否了解class文件的格式？是否能够阅读class文件？"></a>是否了解class文件的格式？是否能够阅读class文件？</h1><p>答：Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在，当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。<br>每个class文件的头4个字节称为魔数，它的唯一作用就是确定这个文件是否为一个能被虚拟机接收的Class文件。紧着着魔数之后的4个字节存储的class文件的版本号，后面是常量池入口。后面是代表访问标志的两个字节，这个表示用于识别一些类或者接口层次的访问信息。再往后就是类索引、父索引与接口索引集合。字段表集合用户描述接口或者类中声明的变量。方法表集合、属性表集合。<br>魔数版本号常量池入口访问标志类索引、父索引与接口索引集合。</p>
<h1 id="JVM监控和调优的一般步骤是什么？"><a href="#JVM监控和调优的一般步骤是什么？" class="headerlink" title="JVM监控和调优的一般步骤是什么？"></a>JVM监控和调优的一般步骤是什么？</h1><p>答：</p>
<ol>
<li>监控GC的状态<br>使用各种JVM工具，查看当前日志，分析当前JVM参数设置，并且分析当前堆内存快照和gc日志，根据实际的各区域内存划分和GC执行时间，觉得是否进行优化；</li>
<li>分析结果，判断虚拟机的配置参数是否需要优化<br>如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化；如果GC时间超过1-3秒，或者频繁GC，则必须优化；<br>注：如果满足下面的指标，则一般不需要进行GC：<br>Minor GC执行时间不到50ms；<br>Minor GC执行不频繁，约10秒一次；<br>Full GC执行时间不到1s；<br>Full GC执行频率不算频繁，不低于10分钟1次；</li>
<li>调整GC类型和内存分配<br>如果内存分配过大或过小，或者采用的GC收集器比较慢，则应该优先调整这些参数，并且先找1台或几台机器进行beta，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择；</li>
<li>不断的分析和调整<br>通过不断的试验和试错，分析并找到最合适的参数</li>
<li>全面应用参数<br>如果找到了最合适的参数，则将这些参数应用到所有服务器，并进行后续跟踪。</li>
</ol>
<h1 id="经常遇到的内存异常有哪些？如何定位和解决这些异常？"><a href="#经常遇到的内存异常有哪些？如何定位和解决这些异常？" class="headerlink" title="经常遇到的内存异常有哪些？如何定位和解决这些异常？"></a>经常遇到的内存异常有哪些？如何定位和解决这些异常？</h1><p>答：<br>1.OutOfMemory</p>
<ul>
<li>java.lang.OutOfMemory：Java heap space<br>首先查看是否是堆溢出或内存泄露。<br>要解决堆内存异常的情况一般的手段是通过内存映像分析工具(如Eclipse Memory Analyzer)对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是有必要的，也就是要先分清楚是内存泄露还是内存溢出。<br>如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露的对象是怎么与GC Roots相连接导致进行垃圾回收时没能回收泄露对象所占的内存，有了泄露对象的信息和GC Roots引用链的信息，就可以准确地定位出泄露代码的位置。<br>如果没有发出内存泄露，也是说，内存中的对象确实还活着，那就应该去检查虚拟机的堆参数(-Xmx与-Xms)，与物理机器对比看是否还可以进一步扩大，从代码上检查是否存在某些对象声明周期过长、持有状态时间过长等，尝试减少程序运行内存消耗。</li>
<li>java.lang.OutOfMemory：PermGen space<br>说明是运行时常量池出现问题。需要扩大方法区来保证动态生成的class可以加载入内存。</li>
<li>java.lang.OutOfMemory<br>直接内存(直接内存并不是虚拟机运行数据区的一部分)可以通过-XX：MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值(-Xmx)一样。<br>虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但是它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方法是unsafe.allocateMemory().<br>由直接内存导致的内存溢出，一个明显的特征是Heap Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是出现了方法区溢出。</li>
</ul>
<p>2.StackOverflowStack<br>抛出StackOverflowStack异常是线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。产生这种内存溢出与栈空间是否足够大并没有任何关系，反而给每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。</p>
<p>出现StackOverflowError异常有时有错误堆栈可以阅读，相对比较容易找到问题的所在。而且，如果使用虚拟机默认参数，在大多数情况下达到1000~2000是完全没有问题的，对于正常的方法调用(包括递归)，这个深度是完全没有问题的。但是如果建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。</p>
<h1 id="是否知道JVM的标准、非标准和非stable参数？"><a href="#是否知道JVM的标准、非标准和非stable参数？" class="headerlink" title="是否知道JVM的标准、非标准和非stable参数？"></a>是否知道JVM的标准、非标准和非stable参数？</h1><p>答：-Xmx ：最大堆大小<br>    -Xms ： 初始堆大小<br>    -Xmn ： 年轻代大小<br>    -XXSurvivorRatio : 年轻代中Eden区和Survivor区的比例<br>    -XX:MaxPermSize ：最大方法区内存大小<br>    -XX:PermSize ：方法区分配的初始内存大小</p>



                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/techlife/Java面试之Spring/" data-toggle="tooltip" data-placement="top" title="Java面试之Spring">&larr; 上一篇</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/techlife/Java面试之Java并发/" data-toggle="tooltip" data-placement="top" title="Java面试之Java并发">下一篇 &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!--打赏-->
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                <!--分享-->
                <br>

                <!-- require APlayer -->
                

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                
				
            </div>

            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#你了解Java内存模型么？"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">你了解Java内存模型么？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#JVM内存区域分为哪几块？分别如何使用？"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">JVM内存区域分为哪几块？分别如何使用？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#直接内存是什么？"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">直接内存是什么？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#JVM内存区域会出现哪几种异常？分别可以在哪块区域出现？出现的条件是什么？"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">JVM内存区域会出现哪几种异常？分别可以在哪块区域出现？出现的条件是什么？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#堆和栈有什么区别？可以从哪些方面进行比较？"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">堆和栈有什么区别？可以从哪些方面进行比较？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#JVM堆内存的结构是怎样的？各个结构存放的是哪种对象？对象如何在各个结构之间迁移？"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">JVM堆内存的结构是怎样的？各个结构存放的是哪种对象？对象如何在各个结构之间迁移？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#垃圾收集算法有哪些？各个算法是如何操作的？各自有什么特点？效率问题？空间问题？"><span class="toc-nav-number">7.</span> <span class="toc-nav-text">垃圾收集算法有哪些？各个算法是如何操作的？各自有什么特点？效率问题？空间问题？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#当前商业虚拟机一般使用的是哪种垃圾收集算法？"><span class="toc-nav-number">8.</span> <span class="toc-nav-text">当前商业虚拟机一般使用的是哪种垃圾收集算法？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#堆内存的各个结构分别使用哪种垃圾收集算法？"><span class="toc-nav-number">9.</span> <span class="toc-nav-text">堆内存的各个结构分别使用哪种垃圾收集算法？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#JVM中为什么会有GC停顿？"><span class="toc-nav-number">10.</span> <span class="toc-nav-text">JVM中为什么会有GC停顿？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#内存溢出和内存泄露的概念分别是什么？有什么区别？能否分别举几个例子？"><span class="toc-nav-number">11.</span> <span class="toc-nav-text">内存溢出和内存泄露的概念分别是什么？有什么区别？能否分别举几个例子？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#如何判断对象是否还活着？简单描述各个算法？"><span class="toc-nav-number">12.</span> <span class="toc-nav-text">如何判断对象是否还活着？简单描述各个算法？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#如何分析和定位内存泄露？"><span class="toc-nav-number">13.</span> <span class="toc-nav-text">如何分析和定位内存泄露？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#可达性算法分析中，哪些对象可以作为GC-roots？这些对象有什么特点？"><span class="toc-nav-number">14.</span> <span class="toc-nav-text">可达性算法分析中，哪些对象可以作为GC roots？这些对象有什么特点？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#full-GC的触发条件有哪三个？"><span class="toc-nav-number">15.</span> <span class="toc-nav-text">full GC的触发条件有哪三个？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#垃圾收集器的职责是什么？"><span class="toc-nav-number">16.</span> <span class="toc-nav-text">垃圾收集器的职责是什么？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#什么时候运行垃圾回收？什么是安全点？什么是安全区域？"><span class="toc-nav-number">17.</span> <span class="toc-nav-text">什么时候运行垃圾回收？什么是安全点？什么是安全区域？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#JVM是如何加载class文件的？"><span class="toc-nav-number">18.</span> <span class="toc-nav-text">JVM是如何加载class文件的？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#JVM加载class文件有哪几个过程？每个过程分别主要干了什么？"><span class="toc-nav-number">19.</span> <span class="toc-nav-text">JVM加载class文件有哪几个过程？每个过程分别主要干了什么？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#类加载过程采用了什么机制？描述一下这种机制？"><span class="toc-nav-number">20.</span> <span class="toc-nav-text">类加载过程采用了什么机制？描述一下这种机制？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Java中的引用有哪几种类型？所引用的对象分别在什么情况在会被回收？"><span class="toc-nav-number">21.</span> <span class="toc-nav-text">Java中的引用有哪几种类型？所引用的对象分别在什么情况在会被回收？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#新生代和老年代分别有哪些垃圾收集器？各自有什么特点？画出那张图？"><span class="toc-nav-number">22.</span> <span class="toc-nav-text">新生代和老年代分别有哪些垃圾收集器？各自有什么特点？画出那张图？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#每种垃圾收集器的运行过程和特点是什么？"><span class="toc-nav-number">23.</span> <span class="toc-nav-text">每种垃圾收集器的运行过程和特点是什么？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#知道哪些JVM的命令行工具？是否都用过？怎么用？"><span class="toc-nav-number">24.</span> <span class="toc-nav-text">知道哪些JVM的命令行工具？是否都用过？怎么用？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#是否了解class文件的格式？是否能够阅读class文件？"><span class="toc-nav-number">25.</span> <span class="toc-nav-text">是否了解class文件的格式？是否能够阅读class文件？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#JVM监控和调优的一般步骤是什么？"><span class="toc-nav-number">26.</span> <span class="toc-nav-text">JVM监控和调优的一般步骤是什么？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#经常遇到的内存异常有哪些？如何定位和解决这些异常？"><span class="toc-nav-number">27.</span> <span class="toc-nav-text">经常遇到的内存异常有哪些？如何定位和解决这些异常？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#是否知道JVM的标准、非标准和非stable参数？"><span class="toc-nav-number">28.</span> <span class="toc-nav-text">是否知道JVM的标准、非标准和非stable参数？</span></a></li></ol>
        
        </div>
      </aside>
    


            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">标签云</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Java" title="Java">Java</a>
                        
                          <a class="tag" href="/tags/#面试" title="面试">面试</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://coolshell.cn" target="_blank">coolshell</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>






<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/kid1994">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 剑知 2020 
                    <br>
                    Powered by <a href="http://www.hexo.io">Hexo</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Theme by <a href="https://github.com/kinggozhang/hexo-theme-ace">ACE</a> 
					
					
					<i class="fa fa-eye" id="leancounter"></i>
					
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

   <script src="https://cdn.staticfile.org/jquery/2.2.4/jquery.min.js"></script>



<!-- Bootstrap Core JavaScript -->

   <script src="https://cdn.staticfile.org/twitter-bootstrap/3.4.1/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


	<script src="/js/particles.js"></script>
	<script src="/js/particles_config.js"></script>



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://kid1994.github.io/techlife/Java面试之Java虚拟机/index.html/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="http://kid1994.github.io/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
