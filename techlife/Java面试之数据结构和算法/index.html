<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="剑知的博客.">
    <meta name="keyword"  content="剑知">
    <link rel="shortcut icon" href="/assets/blogImg/me.jpg">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          Java面试之数据结构和算法 - 剑知
        
    </title>

    <link rel="canonical" href="http://kid1994.github.io/techlife/Java面试之数据结构和算法/">

    <!-- Bootstrap Core CSS -->

   <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/3.4.1/css/bootstrap.min.css">



    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/beantech.min.css">

    <link rel="stylesheet" href="/css/donate.css">
	<link rel="stylesheet" href="/css/w3.css">
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->


    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
    }
   .post-heading{
    padding:20px;
    }
  .person {
    border: 10px solid transparent;
    margin-bottom: 25px;
    width: 80%;
    height: 80%;
    opacity: 0.7;
  }
  .person:hover {
    border-color: #f1f1f1;
  }

</style>

<header id="headerid" class="w3-indigo intro-header" style="position:relative;">
    <!-- Signature -->
	
        <div class="container">
            <div class=" row" >
			
			<canvas id="particles-js-canvas" style="position:absolute;z-index:1;top:0px;left:0px;" width="100%" height="50%"></canvas>
			
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1" style="z-index:2;">
                
                    <div class="post-heading" style="padding:40px">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#Java" title="Java">Java</a>
                            
                              <a class="tag" href="/tags/#面试" title="面试">面试</a>
                            
                        </div>
                        <h1>Java面试之数据结构和算法</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by 剑知 on
                            2018-04-08
                        </span>
                    </div>
                
                </div>
            </div>
        </div>
  
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">剑知</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a  href="/">主页</a>
                    </li>
		    
                    

                        
                        <li>
           
                            <a  href="/技术人生">技术人生</a>
                           
                        </li>
                        
                    

                        
                        <li>
           
                            <a  href="/拿破轮">拿破轮</a>
                           
                        </li>
                        
                    

                        
                        <li>
           
                            <a  href="/我的梦呓">我的梦呓</a>
                           
                        </li>
                        
                    

                        
                        <li>
           
                            <a  href="/好奇心">好奇心</a>
                           
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <p>这是Java面试复习点的数据结构和算法部分。</p>
<p>面经只是一种方法，一种手段，而不是目的，最终要能够自己将点织成线，将线编成面，将面合成体。</p>
<a id="more"></a>
<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
<ul>
<li><a href="#如何根据数据范围决定采用的算法的时间复杂度">如何根据数据范围决定采用的算法的时间复杂度？</a></li>
<li><a href="#尾递归的概念是什么有什么好处">尾递归的概念是什么？有什么好处？</a></li>
<li><a href="#排序算法有哪些每种算法的最好最坏平均时间复杂度空间复杂度是否稳定是否就地算法复杂度是否和初始排列有关画出那张图">排序算法有哪些？每种算法的最好、最坏、平均时间复杂度？空间复杂度？是否稳定？是否就地？算法复杂度是否和初始排列有关？画出那张图？</a></li>
<li><a href="#能否写出每种排序算法">能否写出每种排序算法？</a></li>
<li><a href="#jdk中arrayssort是如何实现的">JDK中Arrays.sort()是如何实现的？</a></li>
<li><a href="#常见的查找算法有哪些速度怎么排">常见的查找算法有哪些？速度怎么排？</a></li>
<li><a href="#能否写出二分查找法需要注意哪些点二分查找有哪些变种">能否写出二分查找法？需要注意哪些点？二分查找有哪些变种？</a></li>
<li><a href="#字符串kmp算法是否会写关键思想是什么实现步骤是什么next数组的含义是什么next数组怎么优化为什么要优化">字符串KMP算法是否会写？关键思想是什么？实现步骤是什么？next数组的含义是什么？next数组怎么优化？为什么要优化？</a></li>
<li><a href="#动态规划的经典问题有哪些">动态规划的经典问题有哪些？</a><ul>
<li><a href="#硬币找零问题">硬币找零问题</a></li>
<li><a href="#装配线调度问题">装配线调度问题？</a></li>
<li><a href="#最长公共子序列问题">最长公共子序列问题？</a></li>
<li><a href="#最长递增子序列问题">最长递增子序列问题？</a></li>
<li><a href="#最大连续子序列和积问题">最大连续子序列和/积问题？</a></li>
<li><a href="#矩阵链乘问题">矩阵链乘问题</a></li>
<li><a href="#0-1背包问题">0-1背包问题？</a></li>
<li><a href="#有代价的最短路径问题">有代价的最短路径问题？</a></li>
</ul>
</li>
<li><a href="#筛素数法如何实现关键思想是什么">筛素数法如何实现？关键思想是什么？</a></li>
<li><a href="#位操作有哪些">位操作有哪些？</a><ul>
<li><a href="#优先级怎么样">优先级怎么样？</a></li>
<li><a href="#异或操作有什么特性">异或操作有什么特性？</a></li>
<li><a href="#如何对一个整数在指定位置置01">如何对一个整数在指定位置置0/1？</a></li>
<li><a href="#如何判断奇偶">如何判断奇偶？</a></li>
<li><a href="#交换两个数如何实现">交换两个数如何实现？</a></li>
<li><a href="#交换符号如何实现">交换符号如何实现？</a></li>
<li><a href="#求绝对值如何实现">求绝对值如何实现？</a></li>
<li><a href="#筛素数法如何使用位操作进行空间压缩">筛素数法如何使用位操作进行空间压缩？</a></li>
<li><a href="#高低位交换如何实现">高低位交换如何实现？</a></li>
<li><a href="#二进制逆序如何实现">二进制逆序如何实现？</a></li>
<li><a href="#如何计算二进制中1的个数">如何计算二进制中1的个数？</a></li>
<li><a href="#缺失的数字问题如何解决">缺失的数字问题如何解决？</a></li>
<li><a href="#如何不使用四则运算计算两个数的和">如何不使用四则运算计算两个数的和？</a></li>
</ul>
</li>
<li><a href="#如何寻找最大的k个数">如何寻找最大的K个数？</a></li>
<li><a href="#如何求解最大公约数">如何求解最大公约数？</a></li>
<li><a href="#如何求解fibonacci数列">如何求解Fibonacci数列？</a></li>
<li><a href="#如何同时找出数组中的最大数和最小数如何减少比较的次数">如何同时找出数组中的最大数和最小数？如何减少比较的次数？</a></li>
<li><a href="#如何快速找到满足条件的两个数">如何快速找到满足条件的两个数？</a></li>
<li><a href="#如何求解数组的子数组之和的最大值如何让你的算法从on2到onlgn再到on一步步优化">如何求解数组的子数组之和的最大值？如何让你的算法从O(n^2)到O(n*lgn)再到O(n)一步步优化？</a></li>
<li><a href="#如何计算字符串的相似度">如何计算字符串的相似度？</a></li>
<li><a href="#如何从无头单链表中删除节点">如何从无头单链表中删除节点？</a></li>
<li><a href="#如何判断两个链表是否相交">如何判断两个链表是否相交？</a></li>
<li><a href="#如何判断一个链表是否有环">如何判断一个链表是否有环？</a></li>
<li><a href="#如何使从队列中取最大值操作的效率尽可能高">如何使从队列中取最大值操作的效率尽可能高？</a></li>
<li><a href="#树的基本概念是否都知道满二叉树完全二叉树">树的基本概念是否都知道？满二叉树？完全二叉树？</a></li>
<li><a href="#二叉树的基本性质有哪些关于二叉树的各种计算是否都会二叉树的各种属性计算树的高度计算树的各层总节点树">二叉树的基本性质有哪些？关于二叉树的各种计算是否都会？二叉树的各种属性？计算树的高度？计算树的（各层/总）节点树？</a></li>
<li><a href="#能否写出二叉树的先序中序和后序遍历的算法">能否写出二叉树的先序、中序和后序遍历的算法？</a></li>
<li><a href="#能否写出二叉树的深度优先和广度优先算法">能否写出二叉树的深度优先和广度优先算法？</a></li>
<li><a href="#如何计算二叉树中节点的最大距离">如何计算二叉树中节点的最大距离？</a></li>
<li><a href="#如何根据二叉树的先序和中序遍历结果重建二叉树">如何根据二叉树的先序和中序遍历结果重建二叉树？</a></li>
<li><a href="#如何分层遍历二叉树">如何分层遍历二叉树？</a></li>
<li><a href="#是否了解二叉查找树平衡二叉树avl树线索二叉树哈夫曼树红黑树和trie树的基本概念各有哪些应用">是否了解二叉查找树，平衡二叉树（AVL树），线索二叉树，哈夫曼树，红黑树，和Trie树的基本概念？各有哪些应用？</a></li>
<li><a href="#图的基本概念是否知道有向图无向图稀疏图稠密图完全图简单图连通图连通分量强连通图强连通分量图的入度和出度">图的基本概念是否知道？有向图？无向图？稀疏图？稠密图？完全图？简单图？连通图？连通分量？强连通图？强连通分量？图的入度和出度？</a></li>
<li><a href="#图的表示有哪几种方式">图的表示有哪几种方式？</a></li>
<li><a href="#图的遍历方式有哪几种各自有什么异同分别在什么时候使用">图的遍历方式有哪几种？各自有什么异同？分别在什么时候使用？</a></li>
<li><a href="#如何统计图中连通分量的数量">如何统计图中连通分量的数量？</a></li>
<li><a href="#如何检测图中是否有环">如何检测图中是否有环？</a></li>
<li><a href="#如何解决二分图判断双色问题">如何解决二分图判断（双色问题）？</a></li>
<li><a href="#能否写出图的拓扑排序算法">能否写出图的拓扑排序算法？</a></li>
<li><a href="#求解图的最小生成树有哪些前提所有最小生成树算法的基础是什么使用的是哪种算法策略dp还是贪心有哪几种实现算法">求解图的最小生成树有哪些前提？所有最小生成树算法的基础是什么，使用的是哪种算法策略，dp还是贪心？有哪几种实现算法？</a></li>
<li><a href="#求解最短路径算法有哪几种分别有什么特点各自的时间复杂度和空间复杂度是多少">求解最短路径算法有哪几种？分别有什么特点？各自的时间复杂度和空间复杂度是多少？</a></li>
</ul>
<!-- /TOC -->
<h1 id="如何根据数据范围决定采用的算法的时间复杂度？"><a href="#如何根据数据范围决定采用的算法的时间复杂度？" class="headerlink" title="如何根据数据范围决定采用的算法的时间复杂度？"></a>如何根据数据范围决定采用的算法的时间复杂度？</h1><p>答：</p>
<table>
<thead>
<tr>
<th style="text-align:center">数据范围</th>
<th style="text-align:center">复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">N&lt;=20</td>
<td style="text-align:center">O(2n)</td>
</tr>
<tr>
<td style="text-align:center">　20&lt;N&lt;=100</td>
<td style="text-align:center">O(n3)  </td>
</tr>
<tr>
<td style="text-align:center">100&lt;N&lt;=1000</td>
<td style="text-align:center">O(n2)</td>
</tr>
<tr>
<td style="text-align:center">10000&lt;N&lt;=105</td>
<td style="text-align:center">O(nlogn)</td>
</tr>
<tr>
<td style="text-align:center">105&lt;N&lt;=108</td>
<td style="text-align:center">O(n)</td>
</tr>
<tr>
<td style="text-align:center">N&gt;108</td>
<td style="text-align:center">O(logn)</td>
</tr>
</tbody>
</table>
<h1 id="尾递归的概念是什么？有什么好处？"><a href="#尾递归的概念是什么？有什么好处？" class="headerlink" title="尾递归的概念是什么？有什么好处？"></a>尾递归的概念是什么？有什么好处？</h1><p>答：能够降低栈的深度，防止栈溢出。</p>
<h1 id="排序算法有哪些？每种算法的最好、最坏、平均时间复杂度？空间复杂度？是否稳定？是否就地？算法复杂度是否和初始排列有关？画出那张图？"><a href="#排序算法有哪些？每种算法的最好、最坏、平均时间复杂度？空间复杂度？是否稳定？是否就地？算法复杂度是否和初始排列有关？画出那张图？" class="headerlink" title="排序算法有哪些？每种算法的最好、最坏、平均时间复杂度？空间复杂度？是否稳定？是否就地？算法复杂度是否和初始排列有关？画出那张图？"></a>排序算法有哪些？每种算法的最好、最坏、平均时间复杂度？空间复杂度？是否稳定？是否就地？算法复杂度是否和初始排列有关？画出那张图？</h1><p>答：<br><img src="/techlife/Java面试之数据结构和算法/1.jpg" alt=""></p>
<p>注意：其中归并排序的空间复杂度应为O(n)；<br>      快速排序空间复杂度最好的情况（每一次都平分数组）为O(lgn);最坏的情况（退化为冒泡排序）为O(n);<br>如果最好和最坏时间复杂度一样，那就和数据初始排列无关；否则就是有关。</p>
<p><a href="https://blog.csdn.net/yuzhihui_no1/article/details/44198701" target="_blank" rel="noopener">参考1</a><br><a href="https://www.cnblogs.com/lizr-ithouse/p/5839384.html" target="_blank" rel="noopener">参考2</a><br><a href="https://blog.csdn.net/yuzhihui_no1/article/details/44223225" target="_blank" rel="noopener">参考3</a><br><a href="https://blog.csdn.net/hr10707020217/article/details/10581371" target="_blank" rel="noopener">参考4</a></p>
<h1 id="能否写出每种排序算法？"><a href="#能否写出每种排序算法？" class="headerlink" title="能否写出每种排序算法？"></a>能否写出每种排序算法？</h1><p>答：</p>
<p>1.直接插入排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**直接插入排序*/</span><br><span class="line">private static void insertSort(int[] a)&#123;</span><br><span class="line">    for (int i = 1;i &lt; a.length;i++)&#123;</span><br><span class="line">        for (int j = i;j &gt; 0;j--)&#123;</span><br><span class="line">            int x = j - 1;//note1</span><br><span class="line">            if(a[j] &lt; a[x])&#123;//note2</span><br><span class="line">                int temp = a[x];</span><br><span class="line">                a[x] = a[j];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            else break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.Shell排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**希尔排序*/</span><br><span class="line">private static void shellSort(int[] a)&#123;</span><br><span class="line">    //计算最大间隔</span><br><span class="line">    int h = 0;</span><br><span class="line">    while (h &lt; a.length / 3 + 1)&#123;//note1</span><br><span class="line">        h = h * 3 + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    while (h &gt; 0)&#123;</span><br><span class="line">        //直接插入排序</span><br><span class="line">        for (int i = h;i &lt; a.length;i++)&#123;</span><br><span class="line">            int temp = a[i];</span><br><span class="line">            int j = i;</span><br><span class="line">            while (j &gt;= h &amp;&amp; a[j - h] &gt; temp)&#123;//note2</span><br><span class="line">                a[j] = a[j - h];</span><br><span class="line">                j -=h;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j]= temp;</span><br><span class="line">        &#125;</span><br><span class="line">        //缩小间隔</span><br><span class="line">        h = (h - 1) / 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.简单选择排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**简单选择排序*/</span><br><span class="line">private static void selectSort(int[] a)&#123;</span><br><span class="line">    for (int i = 0;i &lt; a.length - 1;i++)&#123;</span><br><span class="line">        int minIndex = i;</span><br><span class="line">        for (int j = i + 1;j &lt; a.length;j++)&#123;</span><br><span class="line">            if (a[j] &lt; a[minIndex]) minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        if(minIndex != i)&#123;</span><br><span class="line">            int temp = a[minIndex];</span><br><span class="line">            a[minIndex] = a[i];</span><br><span class="line">            a[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.堆排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**堆排序*/</span><br><span class="line">private static void heapSort(int[] a)&#123;</span><br><span class="line">    //构建堆</span><br><span class="line">    for (int i = a.length / 2 - 1; i &gt;= 0;i--)&#123;//i首先指向第一个非叶子节点</span><br><span class="line">        adjustHeap(a, i, a.length);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = a.length - 1;i &gt; 0;i--)&#123;</span><br><span class="line">        int temp = a[0];</span><br><span class="line">        a[0] = a[i];</span><br><span class="line">        a[i] = temp;//将最大的一个放到最后</span><br><span class="line">        adjustHeap(a, 0, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**调整堆*/</span><br><span class="line">private static void adjustHeap(int[] a, int start, int len)&#123;</span><br><span class="line">    int temp = a[start];//保存start节点的值</span><br><span class="line">    for (int i = start * 2 + 1; i &lt; len;i = i * 2 + 1)&#123;//i指向左边的孩子</span><br><span class="line">        if(i &lt; len - 1 &amp;&amp; a[i] &lt; a[i + 1]) i++;//i指向左右孩子中较大的一个</span><br><span class="line">        if (a[i] &lt; temp) break;//如果不需要调整直接退出循环</span><br><span class="line">        a[start] = a[i];//将较大的孩子放到根节点</span><br><span class="line">        start = i;//start指向当前的根节点</span><br><span class="line">    &#125;</span><br><span class="line">    a[start] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.冒泡排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**冒泡排序*/</span><br><span class="line">private static void bubbleSort(int[] a)&#123;</span><br><span class="line">    for (int i = 0;i &lt; a.length;i++)&#123;</span><br><span class="line">        boolean swapFlag = false;</span><br><span class="line">        for (int j = a.length - 1;j &gt; i;j--)&#123;</span><br><span class="line">            if(a[j] &lt; a[j - 1])&#123;</span><br><span class="line">                int temp = a[j];</span><br><span class="line">                a[j] = a[j - 1];</span><br><span class="line">                a[j - 1] = temp;</span><br><span class="line">                swapFlag = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!swapFlag) break;//如果有一趟没有交换，说明已经有序，直接退出</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>6.快速排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**快速排序*/</span><br><span class="line">private static void quickSort(int[] a, int start, int end)&#123;</span><br><span class="line">    if(start &gt;= end) return;//递归边界</span><br><span class="line">    int index = partition(a, start, end);</span><br><span class="line">    quickSort(a, start, index - 1);//快排左边</span><br><span class="line">    quickSort(a, index + 1, end);//快排右边</span><br><span class="line">&#125;</span><br><span class="line">/**快排划分*/</span><br><span class="line">private static int partition(int[] a, int start, int end)&#123;</span><br><span class="line">    int p = a[start];//取第一个为轴元素</span><br><span class="line">    while (start &lt; end)&#123;</span><br><span class="line">        while (start &lt; end &amp;&amp; a[end] &gt; p) end--;//先从右边挖坑</span><br><span class="line">        a[start] = a[end];//填左边的坑</span><br><span class="line">        while (start &lt; end &amp;&amp; a[start] &lt;= p) start++;//再从左边挖坑</span><br><span class="line">        a[end] = a[start];//填右边的坑</span><br><span class="line">    &#125;</span><br><span class="line">    a[start] = p;//最后把轴元素填上</span><br><span class="line">    return start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>7.归并排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**归并排序*/</span><br><span class="line">private static void mergeSort(int[] a, int start, int end)&#123;</span><br><span class="line">    if(start == end) return;//递归边界</span><br><span class="line">    int mid = start + (end - start) / 2;</span><br><span class="line">    mergeSort(a, start, mid);</span><br><span class="line">    mergeSort(a, mid + 1, end);</span><br><span class="line">    int[] temp = new int[end - start + 1];</span><br><span class="line">    int i = start, j = mid + 1;</span><br><span class="line">    int k = 0;</span><br><span class="line">    while (i &lt;= mid &amp;&amp; j &lt;= end)&#123;</span><br><span class="line">        if (a[i] &lt; a[j]) temp[k++] = a[i++];</span><br><span class="line">        else temp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (i &lt;= mid) temp[k++] = a[i++];</span><br><span class="line">    while (j &lt;= end) temp[k++] = a[j++];</span><br><span class="line">    for (int x = 0;x &lt; k;x++)&#123;</span><br><span class="line">        a[start + x] = temp[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**迭代方式实现归并排序*/</span><br><span class="line">private static void mergeSort2(int[] a)&#123;</span><br><span class="line">    int len = a.length;</span><br><span class="line">    int[] temp = new int[a.length];//临时数组</span><br><span class="line">    int k = 0;</span><br><span class="line">    int left_min, left_max, right_min, right_max = 0;</span><br><span class="line">    for (int i = 1;i &lt; a.length;i *= 2)&#123;//第一趟两个一组排序，第二趟四个一组排序，类推</span><br><span class="line">        k = 0;</span><br><span class="line">        for (left_min = 0;left_min &lt; a.length - i;left_min = right_max)&#123;</span><br><span class="line">            left_max = right_min = left_min + i;//包左不包右</span><br><span class="line">            right_max = left_max + i;</span><br><span class="line">            if(right_max &gt; a.length) right_max = a.length;</span><br><span class="line">            while (left_min &lt; left_max &amp;&amp; right_min &lt; right_max)&#123;</span><br><span class="line">                if(a[left_min] &lt; a[right_min]) temp[k++] = a[left_min++];</span><br><span class="line">                else temp[k++] = a[right_min++];</span><br><span class="line">            &#125;</span><br><span class="line">            while (left_min &lt; left_max) a[--right_min] = a[--left_max];</span><br><span class="line">            while (k &gt; 0) a[--right_min] = temp[--k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="JDK中Arrays-sort-是如何实现的？"><a href="#JDK中Arrays-sort-是如何实现的？" class="headerlink" title="JDK中Arrays.sort()是如何实现的？"></a>JDK中Arrays.sort()是如何实现的？</h1><h1 id="常见的查找算法有哪些？速度怎么排？"><a href="#常见的查找算法有哪些？速度怎么排？" class="headerlink" title="常见的查找算法有哪些？速度怎么排？"></a>常见的查找算法有哪些？速度怎么排？</h1><p>答：</p>
<ul>
<li>顺序查找(O(n))</li>
<li>分块查找（O(根号n)）</li>
<li>二分查找（O(lgn)）</li>
<li>哈希（O(1)）。</li>
</ul>
<p><a href="https://www.cnblogs.com/yw09041432/p/5908444.html" target="_blank" rel="noopener">参考</a></p>
<h1 id="能否写出二分查找法？需要注意哪些点？二分查找有哪些变种？"><a href="#能否写出二分查找法？需要注意哪些点？二分查找有哪些变种？" class="headerlink" title="能否写出二分查找法？需要注意哪些点？二分查找有哪些变种？"></a>能否写出二分查找法？需要注意哪些点？二分查找有哪些变种？</h1><p>答：注意点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**二分查找算法</span><br><span class="line"> * @param a : 待查找的有序数组</span><br><span class="line"> * @param x ：待查找的数字</span><br><span class="line"> * @return 如果找到返回下标，否则返回-1</span><br><span class="line"> * */</span><br><span class="line">private static int binarySearch(int[] a, int x)&#123;</span><br><span class="line">    int lo = 0, hi = a.length - 1;</span><br><span class="line">    while (lo &lt;= hi)&#123;//note1</span><br><span class="line">        int mid = lo + (hi - lo) / 2;//note2</span><br><span class="line">        if(x &lt; a[mid])&#123;</span><br><span class="line">            hi = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(x &gt; a[mid])&#123;</span><br><span class="line">            lo = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>变种：<br>1.求最后一个小于key的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**变种一:求最后一个小于key的位置*/</span><br><span class="line">private static int binarySearchVariant1(int[] a, int key)&#123;</span><br><span class="line">    int len = a.length;</span><br><span class="line">    int lo = 0, hi = len - 1, mid;</span><br><span class="line">    while (lo &lt;= hi)&#123;</span><br><span class="line">        mid = lo + (hi - lo) / 2;</span><br><span class="line">        if(key &lt;= a[mid])&#123;</span><br><span class="line">            hi = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            lo = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return hi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.求第一个大于等于key的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**变种二：求第一个大于等于key的位置*/</span><br><span class="line">private static int binarySearchVariant2(int[] a, int key)&#123;</span><br><span class="line">    int len = a.length;</span><br><span class="line">    int lo = 0, hi = len - 1, mid;</span><br><span class="line">    while (lo &lt;= hi)&#123;</span><br><span class="line">        mid = lo + (hi - lo) / 2;</span><br><span class="line">        if(key &lt;= a[mid])&#123;</span><br><span class="line">            hi = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            lo = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return lo &lt; len ? lo : -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.求最后一个小于等于key的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**变种三：求最后一个小于等于key的位置*/</span><br><span class="line">private static int binarySearchVariant3(int[] a, int key)&#123;</span><br><span class="line">    int len = a.length;</span><br><span class="line">    int lo = 0, hi = len - 1, mid;</span><br><span class="line">    while (lo &lt;= hi)&#123;</span><br><span class="line">        mid = lo + (hi - lo) / 2;</span><br><span class="line">        if(key &lt; a[mid])&#123;</span><br><span class="line">            hi = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            lo = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return hi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.求第一个大于key的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**变种四：求第一个大于key的位置*/</span><br><span class="line">private static int binarySearchVariant4(int[] a, int key)&#123;</span><br><span class="line">    int len = a.length;</span><br><span class="line">    int lo = 0, hi = len - 1, mid;</span><br><span class="line">    while (lo &lt;= hi)&#123;</span><br><span class="line">        mid = lo + (hi - lo) / 2;</span><br><span class="line">        if(key &lt; a[mid])&#123;</span><br><span class="line">            hi = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            lo = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return lo &lt; len ? lo : -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.求第一个等于key的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**变种五：求第一个等于key的位置*/</span><br><span class="line">private static int binarySearchVariant5(int[] a, int key)&#123;</span><br><span class="line">    int len = a.length;</span><br><span class="line">    int lo = 0, hi = len - 1, mid;</span><br><span class="line">    while(lo &lt;= hi)&#123;</span><br><span class="line">        mid = lo + (hi - lo) / 2;</span><br><span class="line">        if(key &lt;= a[mid])&#123;</span><br><span class="line">            hi = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            lo = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(lo &lt; len &amp;&amp; a[lo] == key) return lo;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>6.求最后一个等于key的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**变种六：求最后一个等于key的位置*/</span><br><span class="line">private static int binarySearchVariant6(int[] a, int key)&#123;</span><br><span class="line">    int len = a.length;</span><br><span class="line">    int lo = 0, hi = len - 1, mid;</span><br><span class="line">    while (lo &lt;= hi)&#123;</span><br><span class="line">        mid = lo + (hi - lo) / 2;</span><br><span class="line">        if(key &lt; a[mid])&#123;</span><br><span class="line">            hi = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            lo = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(hi &gt;= 0 &amp;&amp; a[hi] == key) return hi;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>记忆规律：<br><img src="/techlife/Java面试之数据结构和算法/2.jpg" alt=""></p>
<p><a href="https://www.cnblogs.com/bofengyu/p/6761389.html" target="_blank" rel="noopener">参</a></p>
<h1 id="字符串KMP算法是否会写？关键思想是什么？实现步骤是什么？next数组的含义是什么？next数组怎么优化？为什么要优化？"><a href="#字符串KMP算法是否会写？关键思想是什么？实现步骤是什么？next数组的含义是什么？next数组怎么优化？为什么要优化？" class="headerlink" title="字符串KMP算法是否会写？关键思想是什么？实现步骤是什么？next数组的含义是什么？next数组怎么优化？为什么要优化？"></a>字符串KMP算法是否会写？关键思想是什么？实现步骤是什么？next数组的含义是什么？next数组怎么优化？为什么要优化？</h1><p>答：关键思想：利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配。</p>
<p>实现步骤：计算next数组；利用next数组进行快速匹配。<br>Next数组的含义：表示如果当前字符不匹配，模式串要回退的位置。<br>Next数组优化：当模式串回退后的位置的字符与回退前的位置的字符相同的话，要继续递归回退。再次减少了无用匹配的次数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        //String s = scanner.next();//主串</span><br><span class="line">        String s = &quot;abcabcabc&quot;;//主串</span><br><span class="line">        //String p = scanner.next();//模式串</span><br><span class="line">        String p = &quot;ababab&quot;;//模式串</span><br><span class="line">        int[] next = getNext2(p);//计算next数组</span><br><span class="line">        int i = 0;//主串的索引</span><br><span class="line">        int j = 0;//模式串的索引</span><br><span class="line">        while (i &lt; s.length() &amp;&amp; j &lt; p.length())&#123;</span><br><span class="line">            if(j == -1 || s.charAt(i) == p.charAt(j))&#123;</span><br><span class="line">                i++;j++;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                j = next[j];//只回退模式串</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int subLen = j == p.length()?i - j : -1;</span><br><span class="line">        if(subLen == -1)&#123;</span><br><span class="line">            System.out.println(&quot;false&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            System.out.println(s.substring(subLen, subLen + j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**计算next数组</span><br><span class="line">     * @param p : 模式串</span><br><span class="line">     * @return next数组</span><br><span class="line">     */</span><br><span class="line">    private static int[] getNext(String p)&#123;</span><br><span class="line">        int len = p.length();</span><br><span class="line">        int[] next = new int[len];</span><br><span class="line">        next[0] = -1;</span><br><span class="line">        int j = 0;//索引</span><br><span class="line">        int k = -1;//前k个字符</span><br><span class="line">        while (j &lt; len - 1)&#123;//小于len-1而不是len</span><br><span class="line">            if (k == -1 || p.charAt(j) == p.charAt(k))&#123;</span><br><span class="line">                if(p.charAt(++j) == p.charAt(++k))&#123;</span><br><span class="line">                    next[j] = next[k];//优化next数组的一步</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;next[j] = k;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                k = next[k];//k回退</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;优化的next数组：&quot;);</span><br><span class="line">        for (int i : next) System.out.print(i + &quot; &quot;);</span><br><span class="line">        System.out.println();</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**未优化的计算next数组*/</span><br><span class="line">    private static int[] getNext2(String p)&#123;</span><br><span class="line">        int len = p.length();</span><br><span class="line">        int[] next = new int[len];</span><br><span class="line">        next[0] = -1;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int k = -1;</span><br><span class="line">        while (i &lt; len - 1)&#123;</span><br><span class="line">            if(k == -1 || p.charAt(k) == p.charAt(i))&#123;</span><br><span class="line">                next[++i] = ++k;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                k = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;未优化的next数组：&quot;);</span><br><span class="line">        for (int x : next) System.out.print(x + &quot; &quot;);</span><br><span class="line">        System.out.println();</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/zhangboy/p/7635627.html" target="_blank" rel="noopener">参考</a></p>
<h1 id="动态规划的经典问题有哪些？"><a href="#动态规划的经典问题有哪些？" class="headerlink" title="动态规划的经典问题有哪些？"></a>动态规划的经典问题有哪些？</h1><p><a href="https://www.cnblogs.com/wuyuegb2312/p/3281264.html#i1" target="_blank" rel="noopener">参考</a></p>
<h2 id="硬币找零问题"><a href="#硬币找零问题" class="headerlink" title="硬币找零问题"></a>硬币找零问题</h2><p>答：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 动态规划求解</span><br><span class="line"> * @return 使用的硬币的最少数量</span><br><span class="line"> */</span><br><span class="line">private static int changeMoney(int x, int[] coin)&#123;</span><br><span class="line">    //sum[x]表示组成金额x的最少硬币数量</span><br><span class="line">    //sum[x] = min&#123;sum[x-coin[0]], sum[x-coin[1]],...sum[x-coin[n]]&#125; + 1</span><br><span class="line">    //子结构有n个</span><br><span class="line">    int[] sum = new int[x + 1];</span><br><span class="line">    sum[0] = 0;</span><br><span class="line">    for (int i = 1;i &lt; sum.length;i++) sum[i] = Integer.MAX_VALUE;</span><br><span class="line">    for (int i = 1;i &lt; sum.length;i++)&#123;</span><br><span class="line">        for (int j = 0;j &lt; coin.length;j++)&#123;</span><br><span class="line">            if(i &gt;= coin[j])&#123;</span><br><span class="line">                int temp = sum[i - coin[j]] + 1;</span><br><span class="line">                if(temp &lt; sum[i]) sum[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum[x] == Integer.MAX_VALUE? -1 : sum[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="装配线调度问题？"><a href="#装配线调度问题？" class="headerlink" title="装配线调度问题？"></a>装配线调度问题？</h2><h2 id="最长公共子序列问题？"><a href="#最长公共子序列问题？" class="headerlink" title="最长公共子序列问题？"></a>最长公共子序列问题？</h2><p>答：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**计算最长公共子序列的长度*/</span><br><span class="line">private static int lcs(String s1, String s2)&#123;</span><br><span class="line">    //s1[1...m],s2[1...n],lcs[1...k]</span><br><span class="line">    //if s1[m] == s2[n] ,lcs[k] == s1[m],else lcs(s1[1..m],s2[1...n]) =</span><br><span class="line">    // max&#123;lcs(s1[1...m-1],s2[1...n]), lcs(s1[1...m], s2[1...n-1])&#125;</span><br><span class="line">    //lcs[x][y]表示s1的前x个字符串和s2的前y个字符串的最长公共子序列</span><br><span class="line">    int[][] lcs = new int[s1.length() + 1][s2.length() + 1];</span><br><span class="line">    int[][] dir = new int[s1.length() + 1][s2.length() + 1];//保存子状态</span><br><span class="line">    for (int i = 0;i &lt; s1.length() + 1;i++) lcs[i][0] = 0;</span><br><span class="line">    for (int i = 0;i &lt; s2.length() + 1;i++) lcs[0][i] = 0;</span><br><span class="line">    for (int i = 1;i &lt; s1.length() + 1;i++)&#123;</span><br><span class="line">        for (int j = 1;j &lt; s2.length() + 1;j++)&#123;</span><br><span class="line">            if (s1.charAt(i - 1) == s2.charAt(j - 1)) &#123;</span><br><span class="line">                lcs[i][j] = lcs[i - 1][j - 1] + 1;dir[i][j] = 2;//左上方向</span><br><span class="line">            &#125;</span><br><span class="line">            else if(lcs[i - 1][j] &gt; lcs[i][j - 1]) &#123;</span><br><span class="line">                lcs[i][j] = lcs[i - 1][j];dir[i][j] = 0;//向上方向</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                lcs[i][j] = lcs[i][j - 1];dir[i][j] = 1;//向左方向</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printLCS(dir, s1.length(), s2.length(), s1);//打印lcs</span><br><span class="line">    return lcs[s1.length()][s2.length()];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**打印LCS*/</span><br><span class="line">private static void printLCS(int[][] dir, int x, int y, String s1)&#123;</span><br><span class="line">    if(x &lt; 0 || y &lt; 0) return;</span><br><span class="line">    if (dir[x][y] == 2)&#123;</span><br><span class="line">        printLCS(dir, x - 1, y - 1, s1);</span><br><span class="line">        System.out.print(s1.charAt(x - 1));</span><br><span class="line">    &#125;else if(dir[x][y] == 0) printLCS(dir,x - 1, y, s1);</span><br><span class="line">    else printLCS(dir, x, y - 1, s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最长递增子序列问题？"><a href="#最长递增子序列问题？" class="headerlink" title="最长递增子序列问题？"></a>最长递增子序列问题？</h2><p>答：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**求解lis*/</span><br><span class="line">private static int lis(int[] a)&#123;</span><br><span class="line">    //list[x]表示以a[x]结尾的最长递增子序列的长度</span><br><span class="line">    //list[x] = max&#123;list[k]&#125; + 1,其中0&lt;=k&lt;x,且a[k] &lt; a[x]</span><br><span class="line">    int[] list = new int[a.length];</span><br><span class="line">    list[0] = 1;</span><br><span class="line">    int result = Integer.MIN_VALUE;</span><br><span class="line">    for (int i = 1;i &lt; list.length;i++) list[i] = Integer.MIN_VALUE;</span><br><span class="line">    for (int i = 1;i &lt; list.length;i++)&#123;</span><br><span class="line">        for (int j = 0;j &lt; i;j++)&#123;</span><br><span class="line">            if(a[j] &lt; a[i])&#123;</span><br><span class="line">                list[i] = Math.max(list[i], list[j] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = Math.max(result, list[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最大连续子序列和-积问题？"><a href="#最大连续子序列和-积问题？" class="headerlink" title="最大连续子序列和/积问题？"></a>最大连续子序列和/积问题？</h2><p>答：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**最大连续子序列和*/</span><br><span class="line">private static int maxConsistentSum(int[] a)&#123;</span><br><span class="line">    int maxEndinghere = 0;</span><br><span class="line">    int result = Integer.MIN_VALUE;</span><br><span class="line">    for (int i = 0;i &lt; a.length;i++)&#123;</span><br><span class="line">        //相当于用一个sum[x]表示以x结尾的最大连续子序列和</span><br><span class="line">        //if sum[x-1] &gt; 0,sum[x] = sum[x-1] + a[x]</span><br><span class="line">        //else sum[x] = a[x]</span><br><span class="line">        maxEndinghere = Math.max(maxEndinghere + a[i], a[i]);</span><br><span class="line">        result = Math.max(result, maxEndinghere);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="矩阵链乘问题"><a href="#矩阵链乘问题" class="headerlink" title="矩阵链乘问题"></a>矩阵链乘问题</h2><h2 id="0-1背包问题？"><a href="#0-1背包问题？" class="headerlink" title="0-1背包问题？"></a>0-1背包问题？</h2><p>答：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**0-1背包问题*/</span><br><span class="line">private static int oneZeroPackage(int[] value, int[] weight, int total)&#123;</span><br><span class="line">    //dp[k][w]表示决策k件商品且背包容量为w时能获取的最大价值</span><br><span class="line">    int[][] dp = new int[value.length][total + 1];</span><br><span class="line">    for (int i = 0;i &lt; value.length;i++)&#123;</span><br><span class="line">        for (int j = 0;j &lt; total + 1;j++) dp[i][j] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1;i &lt; value.length;i++)&#123;</span><br><span class="line">        for (int j = 0;j &lt; total + 1;j++)&#123;</span><br><span class="line">            if(weight[i] &gt; j) dp[i][j] = dp[i - 1][j];</span><br><span class="line">            else dp[i][j] = Math.max(value[i] + dp[i - 1][j - weight[i]], dp[i - 1][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[value.length - 1][total];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="有代价的最短路径问题？"><a href="#有代价的最短路径问题？" class="headerlink" title="有代价的最短路径问题？"></a>有代价的最短路径问题？</h2><h1 id="筛素数法如何实现？关键思想是什么？"><a href="#筛素数法如何实现？关键思想是什么？" class="headerlink" title="筛素数法如何实现？关键思想是什么？"></a>筛素数法如何实现？关键思想是什么？</h1><p>答：关键思想：倍数剔除。<br>优化的关键思想：最小素因子筛选。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**筛素数方法一:倍数剔除*/</span><br><span class="line">private static int[] selectPrime(int n)&#123;</span><br><span class="line">    int[] result = new int[n / 3];</span><br><span class="line">    boolean[] flag = new boolean[n + 1];</span><br><span class="line">    for (int i = 0;i &lt; n + 1;i++) flag[i] = true;</span><br><span class="line">    int p = 0;</span><br><span class="line">    for (int i = 2;i &lt; n + 1;i++)&#123;</span><br><span class="line">        if(flag[i])&#123;</span><br><span class="line">            result[p++] = i;</span><br><span class="line">            for (int j = i * 2;j &lt; n + 1;j +=i)&#123;</span><br><span class="line">                flag[j] = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">/**优化版本：最小素因子筛选*/</span><br><span class="line">private static int[] selectPrime2(int n)&#123;</span><br><span class="line">    int[] result = new int[n / 3];</span><br><span class="line">    boolean[] flag = new boolean[n + 1];</span><br><span class="line">    for (int i = 0;i &lt; n + 1;i++) flag[i] = true;</span><br><span class="line">    int p = 0;</span><br><span class="line">    for (int i = 2;i &lt; n + 1;i++)&#123;</span><br><span class="line">        if (flag[i]) result[p++] = i;</span><br><span class="line">        for (int j = 0;j &lt; p &amp;&amp; i * result[j] &lt; n + 1;j++)&#123;</span><br><span class="line">            flag[i * result[j]] = false;</span><br><span class="line">            if(i % result[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="位操作有哪些？"><a href="#位操作有哪些？" class="headerlink" title="位操作有哪些？"></a>位操作有哪些？</h1><p>答：<br><img src="/techlife/Java面试之数据结构和算法/3.jpg" alt=""></p>
<h2 id="优先级怎么样？"><a href="#优先级怎么样？" class="headerlink" title="优先级怎么样？"></a>优先级怎么样？</h2><p>答：位操作优先级较低，因此尽量使用括号。</p>
<h2 id="异或操作有什么特性？"><a href="#异或操作有什么特性？" class="headerlink" title="异或操作有什么特性？"></a>异或操作有什么特性？</h2><p>答：一个数字和自己异或为0.<br>任何一个数字和0异或不变。任何一个数字和-1异或相当于取反。<br>典型应用是寻找缺失的数字。</p>
<h2 id="如何对一个整数在指定位置置0-1？"><a href="#如何对一个整数在指定位置置0-1？" class="headerlink" title="如何对一个整数在指定位置置0/1？"></a>如何对一个整数在指定位置置0/1？</h2><p>答：和0与。和1或。</p>
<h2 id="如何判断奇偶？"><a href="#如何判断奇偶？" class="headerlink" title="如何判断奇偶？"></a>如何判断奇偶？</h2><p>答：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**判断奇偶*/</span><br><span class="line">private static boolean jiou(int a)&#123;</span><br><span class="line">    return (a&amp;1)&gt;0?false : true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="交换两个数如何实现？"><a href="#交换两个数如何实现？" class="headerlink" title="交换两个数如何实现？"></a>交换两个数如何实现？</h2><p>答：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**交换两个数*/</span><br><span class="line">private static void swap(int a, int b)&#123;</span><br><span class="line">    System.out.println(&quot;a=&quot; + a + &quot; &quot; + &quot;b=&quot; + b);</span><br><span class="line">    a = a^b;</span><br><span class="line">    b = a^b;</span><br><span class="line">    a = a^b;</span><br><span class="line">    System.out.println(&quot;a=&quot; + a + &quot; &quot; + &quot;b=&quot; + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="交换符号如何实现？"><a href="#交换符号如何实现？" class="headerlink" title="交换符号如何实现？"></a>交换符号如何实现？</h2><p>答：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**交换符号*/</span><br><span class="line">private static int changeSign(int a)&#123;</span><br><span class="line">    return ~a + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="求绝对值如何实现？"><a href="#求绝对值如何实现？" class="headerlink" title="求绝对值如何实现？"></a>求绝对值如何实现？</h2><p>答：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**求绝对值*/</span><br><span class="line">private static int abs(int a)&#123;</span><br><span class="line">    return (a&gt;&gt;&gt;31)&gt;0?~a + 1 : a;//note算术右移</span><br><span class="line">&#125;</span><br><span class="line">/**求绝对值方法2*/</span><br><span class="line">private static int abs2(int a)&#123;</span><br><span class="line">    int i = 0 - (a &gt;&gt;&gt; 31);</span><br><span class="line">    return ((a ^ i) - i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="筛素数法如何使用位操作进行空间压缩？"><a href="#筛素数法如何使用位操作进行空间压缩？" class="headerlink" title="筛素数法如何使用位操作进行空间压缩？"></a>筛素数法如何使用位操作进行空间压缩？</h2><p>答：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**使用位操作压缩空间*/</span><br><span class="line">private static int[] selectPrime3(int n)&#123;</span><br><span class="line">    int[] result = new int[n / 3];</span><br><span class="line">    int p =0;</span><br><span class="line">    BitSet bitSet = new BitSet(n + 1);</span><br><span class="line">    bitSet.set(0, n + 1);</span><br><span class="line">    for (int i = 2;i &lt; n+1;i++)&#123;</span><br><span class="line">        if (bitSet.get(i)) result[p++] = i;</span><br><span class="line">        for (int j = 0;j &lt; p &amp;&amp; (i * result[j] &lt; n + 1);j++)&#123;</span><br><span class="line">            bitSet.set(i*result[j], false);</span><br><span class="line">            if (i % result[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="高低位交换如何实现？"><a href="#高低位交换如何实现？" class="headerlink" title="高低位交换如何实现？"></a>高低位交换如何实现？</h2><p>答：(x &lt;&lt; 16) | (x &gt;&gt; 16).</p>
<h2 id="二进制逆序如何实现？"><a href="#二进制逆序如何实现？" class="headerlink" title="二进制逆序如何实现？"></a>二进制逆序如何实现？</h2><p>答：<a href="https://blog.csdn.net/liyjupc/article/details/52679528" target="_blank" rel="noopener">参考</a></p>
<h2 id="如何计算二进制中1的个数？"><a href="#如何计算二进制中1的个数？" class="headerlink" title="如何计算二进制中1的个数？"></a>如何计算二进制中1的个数？</h2><p>答：编程之美2.1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**方法一：位运算</span><br><span class="line"> * 时间复杂度O(log2(x))*/</span><br><span class="line">private static int numberOf1(int x)&#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    while (x &gt; 0)&#123;</span><br><span class="line">        result += (x &amp; 1);</span><br><span class="line">        x &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**方法二：时间复杂度只和1的数量有关*/</span><br><span class="line">private static int numberOf12(long x)&#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    while (x != 0)&#123;//note</span><br><span class="line">        x &amp;= (x - 1);</span><br><span class="line">        result++;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="缺失的数字问题如何解决？"><a href="#缺失的数字问题如何解决？" class="headerlink" title="缺失的数字问题如何解决？"></a>缺失的数字问题如何解决？</h2><p>答：异或所有的数字。因为两个相同的数异或为0，而0和任何一个数异或还是该数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**寻找缺失的数字*/</span><br><span class="line">private static int findMissingOne(int[] a)&#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    for (int x : a) result ^= x;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="如何不使用四则运算计算两个数的和？"><a href="#如何不使用四则运算计算两个数的和？" class="headerlink" title="如何不使用四则运算计算两个数的和？"></a>如何不使用四则运算计算两个数的和？</h2><p>答：使用位运算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static int sum(int num1, int num2)&#123;</span><br><span class="line">    while(num2 &gt; 0)&#123;</span><br><span class="line">        int temp = num1 ^ num2;</span><br><span class="line">        num2 = (num1 &amp; num2) &lt;&lt; 1;</span><br><span class="line">        num1 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://www.nowcoder.com/questionTerminal/59ac416b4b944300b617d4f7f111b215" target="_blank" rel="noopener">链接</a></p>
<p>来源：牛客网<br>首先看十进制是如何做的： 5+7=12，三步走 第一步：相加各位的值，不算进位，得到2。 第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。 第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。 第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。 第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。 继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。</p>
<h1 id="如何寻找最大的K个数？"><a href="#如何寻找最大的K个数？" class="headerlink" title="如何寻找最大的K个数？"></a>如何寻找最大的K个数？</h1><p>答：编程之美2.5<br>1.选择排序进行部分排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**方法二：采用选择排序进行部分排序*/</span><br><span class="line">private static int topk2(int[] a, int k)&#123;</span><br><span class="line">    int consK = k;</span><br><span class="line">    int i = 0;</span><br><span class="line">    while (k-- &gt; 0)&#123;</span><br><span class="line">        int max = a[i];</span><br><span class="line">        for (int j = i + 1;j &lt; a.length;j++) max = Math.max(max, a[j]);</span><br><span class="line">        a[i++] = max;</span><br><span class="line">    &#125;</span><br><span class="line">    return a[consK - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.利用快排不断缩小问题规模<br>3.利用二分搜索，不需要对数据进行排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**方法四：利用二分搜索（不需要对数据排序）*/</span><br><span class="line">private static int topk4(int[] a, int k)&#123;</span><br><span class="line">    int max = a[0], min = a[0], mid;</span><br><span class="line">    for (int x : a)&#123;max = Math.max(max, x); min = Math.min(min, x);&#125;</span><br><span class="line">    while (max - min &gt; 1)&#123;</span><br><span class="line">        mid = min + (max - min) / 2;</span><br><span class="line">        int temp = 0;</span><br><span class="line">        //没有排序的话，只能用顺序查找了</span><br><span class="line">        for (int x : a) if(x &gt;= mid) temp++;</span><br><span class="line">        if(temp &gt;= k) min = mid;</span><br><span class="line">        else max = mid ;</span><br><span class="line">    &#125;</span><br><span class="line">    return min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.如果数量很大不能都载入内存，采用堆排序保存前k大的数，只需要扫描一次数据。</p>
<p>5.如果所有数都是正整数，且取值范围不大，可以考虑使用计数排序来达到线性时间复杂度。</p>
<h1 id="如何求解最大公约数？"><a href="#如何求解最大公约数？" class="headerlink" title="如何求解最大公约数？"></a>如何求解最大公约数？</h1><p>答：编程之美2.7<br>1.辗转相除法。取余效率低。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**方法一：辗转相除法.取余操作效率低*/</span><br><span class="line">private static int gcd(int a, int b)&#123;</span><br><span class="line">    while (b &gt; 0)&#123;</span><br><span class="line">        int temp = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.辗转相减法。迭代次数多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**方法二：辗转相减法*/</span><br><span class="line">private static int gcd2(int a, int b)&#123;</span><br><span class="line">    //始终要保证a&gt;b</span><br><span class="line">    if(a &lt; b)&#123;int temp = a;a = b;b = temp;&#125;</span><br><span class="line">    while (b &gt; 0)&#123;</span><br><span class="line">        int temp = a - b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">        //始终要保证a&gt;b</span><br><span class="line">        if(a &lt; b)&#123;int t = a;a = b;b = t;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.结合方法一和方法二，采用位运算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**结合方法一和方法二：使用位运算*/</span><br><span class="line">private static int gcd3(int a, int b)&#123;</span><br><span class="line">    if(a &lt; b) return gcd3(b, a);</span><br><span class="line">    if(b == 0) return a;</span><br><span class="line">    if((a &amp; 1) == 0)&#123;//a为偶数</span><br><span class="line">        if((b &amp; 1) == 0) return gcd3(a &gt;&gt;&gt; 1, b &gt;&gt;&gt; 1) &lt;&lt; 1;</span><br><span class="line">        else return gcd3(a &gt;&gt;&gt; 1, b);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;//a为奇数</span><br><span class="line">        if((b &amp; 1) == 0) return gcd3(a, b &gt;&gt;&gt; 1);</span><br><span class="line">        else return gcd3(b, a - b);//ab都为奇数，采用辗转相减法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="如何求解Fibonacci数列？"><a href="#如何求解Fibonacci数列？" class="headerlink" title="如何求解Fibonacci数列？"></a>如何求解Fibonacci数列？</h1><p>答：编程之美2.9<br>1.根据递推式递归求解<br>2.备忘录法减少重复计算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**方法一:备忘录*/</span><br><span class="line">private static int[] fibonacci(int n)&#123;</span><br><span class="line">    int[] result = new int[n];</span><br><span class="line">    result[0] = 0;</span><br><span class="line">    result[1] = 1;</span><br><span class="line">    for (int i = 2;i &lt; n;i++) result[i] = result[i-1] + result[i-2];</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.求解通项公式</p>
<h1 id="如何同时找出数组中的最大数和最小数？如何减少比较的次数？"><a href="#如何同时找出数组中的最大数和最小数？如何减少比较的次数？" class="headerlink" title="如何同时找出数组中的最大数和最小数？如何减少比较的次数？"></a>如何同时找出数组中的最大数和最小数？如何减少比较的次数？</h1><p>答：编程之美2.10</p>
<ol>
<li>直接遍历一遍数组。需要比较的次数为2*N</li>
<li>先两两比较相邻的两个数，将较小的数放在奇数位上，较大的数放在偶数位上，最后分别遍历奇数和偶数位找出最大和最小值。需要比较的次数为1.5*N（优化：可以不破坏原数组，在相邻两个数的比较的过程中不断更新max和min）</li>
</ol>
<h1 id="如何快速找到满足条件的两个数？"><a href="#如何快速找到满足条件的两个数？" class="headerlink" title="如何快速找到满足条件的两个数？"></a>如何快速找到满足条件的两个数？</h1><p>答：编程之美2.12</p>
<ol>
<li>方法一：暴力两层循环。时间复杂度O(n^2)</li>
<li>方法二：先对数据进行排序，第2层循环就变为二分查找操作。时间复杂度O(n*lgn)</li>
<li>方法三：参考方法二，将二分查找法改为hash查找。时间复杂度为O(n)。但是需要O(n)的额外空间。用空间换时间。</li>
<li>方法四：先对数据进行排序，然后使用头尾两个指针遍历一遍求两个指针指向数字的和。时间复杂度为O(n*lgn)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static void twoSum(int[] a,int x)&#123;</span><br><span class="line">    Arrays.sort(a);</span><br><span class="line">    int l = 0, r = a.length - 1;</span><br><span class="line">    while (l &lt; r)&#123;</span><br><span class="line">        if(a[l] + a[r] &lt; x) l++;</span><br><span class="line">        else if(a[l] + a[r] &gt; x) r--;</span><br><span class="line">        else System.out.println(a[l++] + &quot; &quot; + a[r--]);</span><br><span class="line">    &#125;</span><br><span class="line">    if(l == r) System.out.println(&quot;not found&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="如何求解数组的子数组之和的最大值？如何让你的算法从O-n-2-到O-n-lgn-再到O-n-一步步优化？"><a href="#如何求解数组的子数组之和的最大值？如何让你的算法从O-n-2-到O-n-lgn-再到O-n-一步步优化？" class="headerlink" title="如何求解数组的子数组之和的最大值？如何让你的算法从O(n^2)到O(n*lgn)再到O(n)一步步优化？"></a>如何求解数组的子数组之和的最大值？如何让你的算法从O(n^2)到O(n*lgn)再到O(n)一步步优化？</h1><p>答：编程之美2.14<br>1.方法一：暴力求解。时间复杂度O(n^3)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**方法一：暴力求解。O(n^3)*/</span><br><span class="line">private static int maxSum(int[] a)&#123;</span><br><span class="line">    int result = Integer.MIN_VALUE;</span><br><span class="line">    for (int i = 0;i &lt; a.length;i++)&#123;</span><br><span class="line">        for (int j = i;j &lt; a.length;j++)&#123;</span><br><span class="line">            int temp = 0;</span><br><span class="line">            for (int k = i;k &lt;= j;k++)&#123;</span><br><span class="line">                temp += a[k];</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(result, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.方法二:利用sum[i…j]=sum[i…j-1]+a[j]来减少重复计算。时间复杂度O(n^2).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**方法二：利用sum[i...j] = sum[i...j-1] + a[j]来减少重复计算.O(n^2)*/</span><br><span class="line">private static int maxSum2(int[] a)&#123;</span><br><span class="line">    int result = Integer.MIN_VALUE;//note要初始化为最小值</span><br><span class="line">    for (int i = 0;i &lt; a.length;i++)&#123;</span><br><span class="line">        int temp = 0;</span><br><span class="line">        for (int j = i;j &lt; a.length;j++)&#123;</span><br><span class="line">            temp += a[j];</span><br><span class="line">            result = Math.max(result, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.方法三：分治法，将问题规模减半。时间复杂度为O(n*lgn)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**方法三：分治法。将问题规模减半。O(n*lgn)*/</span><br><span class="line">private static int maxSum3(int[] a, int l, int r)&#123;</span><br><span class="line">    if(l == r) return a[l];//递归边界</span><br><span class="line">    int mid = l + (r - l) / 2;//中间位置</span><br><span class="line">    int sum1 = maxSum3(a, l, mid);//左半边最大子数组和</span><br><span class="line">    int sum2 = maxSum3(a, mid + 1, r);//右半边最大子数组和</span><br><span class="line">    int sum3left = a[mid], sum3right = a[mid + 1];</span><br><span class="line">    int temp1 = sum3left, temp2 = sum3right;</span><br><span class="line">    int midTemp = mid;</span><br><span class="line">    while (--midTemp &gt;= l) &#123;</span><br><span class="line">        temp1 += a[midTemp];</span><br><span class="line">        sum3left = Math.max(sum3left, temp1);</span><br><span class="line">    &#125;</span><br><span class="line">    midTemp = mid + 1;</span><br><span class="line">    while (++midTemp &lt;= r) &#123;</span><br><span class="line">        temp2 += a[midTemp];</span><br><span class="line">        sum3right = Math.max(sum3right, temp2);</span><br><span class="line">    &#125;</span><br><span class="line">    int sum3 = sum3left + sum3right;//跨越左半边和右半边的最大子数组和</span><br><span class="line">    return Math.max(Math.max(sum1, sum2), sum3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.方法四：动态规划。时间复杂度为O(n)。即最大连续子序列和问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**最大连续子序列和*/</span><br><span class="line">private static int maxConsistentSum(int[] a)&#123;</span><br><span class="line">    int maxEndinghere = 0;</span><br><span class="line">    int result = Integer.MIN_VALUE;</span><br><span class="line">    for (int i = 0;i &lt; a.length;i++)&#123;</span><br><span class="line">        //相当于用一个sum[x]表示以x结尾的最大连续子序列和</span><br><span class="line">        //if sum[x-1] &gt; 0,sum[x] = sum[x-1] + a[x]</span><br><span class="line">        //else sum[x] = a[x]</span><br><span class="line">        maxEndinghere = Math.max(maxEndinghere + a[i], a[i]);</span><br><span class="line">        result = Math.max(result, maxEndinghere);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="如何计算字符串的相似度？"><a href="#如何计算字符串的相似度？" class="headerlink" title="如何计算字符串的相似度？"></a>如何计算字符串的相似度？</h1><h1 id="如何从无头单链表中删除节点？"><a href="#如何从无头单链表中删除节点？" class="headerlink" title="如何从无头单链表中删除节点？"></a>如何从无头单链表中删除节点？</h1><p>答：编程之美3.4</p>
<ol>
<li>方法一：狸猫换太子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**方法一：狸猫换太子*/</span><br><span class="line">private static void deleteRandomNode(Node node)&#123;</span><br><span class="line">    node.value = node.next.value;//将后一个节点的值赋给当前节点</span><br><span class="line">    node.next = node.next.next;//删除后一个节点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="如何判断两个链表是否相交？"><a href="#如何判断两个链表是否相交？" class="headerlink" title="如何判断两个链表是否相交？"></a>如何判断两个链表是否相交？</h1><h1 id="如何判断一个链表是否有环？"><a href="#如何判断一个链表是否有环？" class="headerlink" title="如何判断一个链表是否有环？"></a>如何判断一个链表是否有环？</h1><h1 id="如何使从队列中取最大值操作的效率尽可能高？"><a href="#如何使从队列中取最大值操作的效率尽可能高？" class="headerlink" title="如何使从队列中取最大值操作的效率尽可能高？"></a>如何使从队列中取最大值操作的效率尽可能高？</h1><h1 id="树的基本概念是否都知道？满二叉树？完全二叉树？"><a href="#树的基本概念是否都知道？满二叉树？完全二叉树？" class="headerlink" title="树的基本概念是否都知道？满二叉树？完全二叉树？"></a>树的基本概念是否都知道？满二叉树？完全二叉树？</h1><p>答：</p>
<ol>
<li>满二叉树：除最后一层外，每一层的所有节点都有两个孩子节点的二叉树。</li>
<li>完全二叉树：一棵二叉树只有倒数第二层的节点的度数可以小于2，而且最后一层的叶子节点都要集中在左侧。</li>
</ol>
<h1 id="二叉树的基本性质有哪些？关于二叉树的各种计算是否都会？二叉树的各种属性？计算树的高度？计算树的（各层-总）节点树？"><a href="#二叉树的基本性质有哪些？关于二叉树的各种计算是否都会？二叉树的各种属性？计算树的高度？计算树的（各层-总）节点树？" class="headerlink" title="二叉树的基本性质有哪些？关于二叉树的各种计算是否都会？二叉树的各种属性？计算树的高度？计算树的（各层/总）节点树？"></a>二叉树的基本性质有哪些？关于二叉树的各种计算是否都会？二叉树的各种属性？计算树的高度？计算树的（各层/总）节点树？</h1><p>答：性质：</p>
<ol>
<li>第i层最多有2^(i-1)个节点。（i &gt;= 1）</li>
<li>深度为k(k &gt;= 0)的二叉树最少有k个节点，最多有2^k – 1个节点。</li>
<li>对于任何一棵非空二叉树，叶子节点的数量 = 度为2的节点的数量 + 1.</li>
<li>具有n个节点的二叉树的深度为log(2,n+1)向上取整。</li>
<li>给一棵完全二叉自上向下，自左向右给所有节点编号1,2,3,4…则：</li>
</ol>
<p>1)    若i=1,则i为父节点；否则i的父节点为i/2向下取整。(求父节点)</p>
<p>2)    若2<em>i&lt;=n,则2</em>i为i的左孩子。（求孩子节点）</p>
<p>3)    若2<em>i+1&lt;=n，则2</em>i+1为i的右孩子（求孩子节点）</p>
<p>4)    若i为奇数，且i!=1,则i处于右孩子位置，左孩子为i-1.（求兄弟节点）</p>
<p>5)    若i为偶数，且i!=n，则i处于左孩子位置，右孩子为i+1.（求兄弟节点）</p>
<p><a href="https://blog.csdn.net/PokemonWei/article/details/71405001" target="_blank" rel="noopener">参考</a></p>
<h1 id="能否写出二叉树的先序、中序和后序遍历的算法？"><a href="#能否写出二叉树的先序、中序和后序遍历的算法？" class="headerlink" title="能否写出二叉树的先序、中序和后序遍历的算法？"></a>能否写出二叉树的先序、中序和后序遍历的算法？</h1><p>答：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**先序遍历*/</span><br><span class="line">private static void preOrder(TreeNode root)&#123;</span><br><span class="line">    if(root == null) return;</span><br><span class="line">    System.out.print(root.value + &quot; &quot;);</span><br><span class="line">    preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**中序遍历*/</span><br><span class="line">private static void midOrder(TreeNode root)&#123;</span><br><span class="line">    if(root == null)return;</span><br><span class="line">    midOrder(root.left);</span><br><span class="line">    System.out.print(root.value + &quot; &quot;);</span><br><span class="line">    midOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**后序遍历*/</span><br><span class="line">private static void postOrder(TreeNode root)&#123;</span><br><span class="line">    if (root == null) return;</span><br><span class="line">    postOrder(root.left);</span><br><span class="line">    postOrder(root.right);</span><br><span class="line">    System.out.print(root.value + &quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="能否写出二叉树的深度优先和广度优先算法？"><a href="#能否写出二叉树的深度优先和广度优先算法？" class="headerlink" title="能否写出二叉树的深度优先和广度优先算法？"></a>能否写出二叉树的深度优先和广度优先算法？</h1><p>答：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**层级遍历*/</span><br><span class="line">private static void stageOrder(TreeNode root)&#123;</span><br><span class="line">    Deque&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();//队列</span><br><span class="line">    queue.offerLast(root);</span><br><span class="line">    while (!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode temp = queue.pollFirst();</span><br><span class="line">        System.out.print(temp.value + &quot; &quot;);</span><br><span class="line">        if(temp.left != null) queue.offerLast(temp.left);</span><br><span class="line">        if(temp.right != null) queue.offerLast(temp.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**深度优先遍历*/</span><br><span class="line">private static void dfs(TreeNode root)&#123;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;();//栈</span><br><span class="line">    stack.offerLast(root);</span><br><span class="line">    while (!stack.isEmpty())&#123;</span><br><span class="line">        TreeNode temp = stack.pollLast();</span><br><span class="line">        System.out.print(temp.value + &quot; &quot;);</span><br><span class="line">        if(temp.right != null) stack.offerLast(temp.right);</span><br><span class="line">        if(temp.left != null) stack.offerLast(temp.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="如何计算二叉树中节点的最大距离？"><a href="#如何计算二叉树中节点的最大距离？" class="headerlink" title="如何计算二叉树中节点的最大距离？"></a>如何计算二叉树中节点的最大距离？</h1><h1 id="如何根据二叉树的先序和中序遍历结果重建二叉树？"><a href="#如何根据二叉树的先序和中序遍历结果重建二叉树？" class="headerlink" title="如何根据二叉树的先序和中序遍历结果重建二叉树？"></a>如何根据二叉树的先序和中序遍历结果重建二叉树？</h1><h1 id="如何分层遍历二叉树？"><a href="#如何分层遍历二叉树？" class="headerlink" title="如何分层遍历二叉树？"></a>如何分层遍历二叉树？</h1><p>答：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**层级遍历*/</span><br><span class="line">private static void stageOrder(TreeNode root)&#123;</span><br><span class="line">    Deque&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();//队列</span><br><span class="line">    queue.offerLast(root);</span><br><span class="line">    while (!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode temp = queue.pollFirst();</span><br><span class="line">        System.out.print(temp.value + &quot; &quot;);</span><br><span class="line">        if(temp.left != null) queue.offerLast(temp.left);</span><br><span class="line">        if(temp.right != null) queue.offerLast(temp.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="是否了解二叉查找树，平衡二叉树（AVL树），线索二叉树，哈夫曼树，红黑树，和Trie树的基本概念？各有哪些应用？"><a href="#是否了解二叉查找树，平衡二叉树（AVL树），线索二叉树，哈夫曼树，红黑树，和Trie树的基本概念？各有哪些应用？" class="headerlink" title="是否了解二叉查找树，平衡二叉树（AVL树），线索二叉树，哈夫曼树，红黑树，和Trie树的基本概念？各有哪些应用？"></a>是否了解二叉查找树，平衡二叉树（AVL树），线索二叉树，哈夫曼树，红黑树，和Trie树的基本概念？各有哪些应用？</h1><p>答：<br>1.二叉查找树：它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉查找树。没有键值相等的节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**插入*/</span><br><span class="line">private static TreeNode insert(TreeNode root, int value)&#123;</span><br><span class="line">    if (root == null) root = new TreeNode(value);</span><br><span class="line">    else &#123;</span><br><span class="line">        TreeNode p = root, parent = p;</span><br><span class="line">        boolean left = true;</span><br><span class="line">        while (p != null)&#123;</span><br><span class="line">            parent = p;</span><br><span class="line">            if(value &lt; p.value)&#123;</span><br><span class="line">                left = true;</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                left = false;</span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(left) parent.left = new TreeNode(value);</span><br><span class="line">        else parent.right = new TreeNode(value);</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.平衡二叉树（AVL树）：它是一棵空树或者左右子树高度的绝对值不超过1，并且左右子树都是一棵平衡二叉树。AVL树是由二叉查找树引入的，因为二叉查找树的添加和删除操作会改变左右子树的高度，导致左右子树不平衡，从而使查找的效率由O(lgn)渐渐退化为O(n)。每个节点都有一个平衡因子，表示右边子树的高度减去左边子树的高度，取值为-1,0或1。插入和删除的过程中要旋转调整平衡因子保持平衡。<br>应用：windows对进程地址空间的管理用到了平衡二叉树。</p>
<p><a href="https://blog.csdn.net/wanglelelihuanhuan/article/details/51863275" target="_blank" rel="noopener">参考</a></p>
<p>3.红黑树：是一种平衡二叉树，但不是一种完美的平衡二叉树，追求局部平衡。红黑树有一个重要的特性，从根节点到任一叶子节点的最长路径的长度不大于最短路径长度的两倍。给定一棵黑色高度为N的红黑树，从根节点到叶子节点的最短长度为N-1，最长长度为2*(N-1)。红黑树满足以下性质：</p>
<ul>
<li>节点是红色或者黑色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点（空节点）是黑色。</li>
<li>每个红色节点的两个子节点是黑色的。</li>
<li>从任一节点到其每个叶子节点的所有路径都包含相同数量的黑色节点。</li>
</ul>
<p>红黑树能够保证在最坏情况下，基本的动态几何操作的时间复杂度能达到O(lgn)。<br>红黑树是牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。</p>
<p>相比于BST，因为红黑树可以能确保树的最长路径不大于两倍的最短路径的长度，所以可以看出它的查找效果是有最低保证的。在最坏的情况下也可以保证O(logN)的，这是要好于二叉查找树的。因为二叉查找树最坏情况可以让查找达到O(N)。</p>
<p>红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高，所以在插入和删除中所做的后期维护操作肯定会比红黑树要耗时好多，但是他们的查找效率都是O(logN)，所以红黑树应用还是高于AVL树的. 实际上插入 AVL 树和红黑树的速度取决于你所插入的数据.如果你的数据分布较好,则比较宜于采用 AVL树(例如随机产生系列数),但是如果你想处理比较杂乱的情况,则红黑树是比较快的。</p>
<p>总体来说，hash查找速度会比map快，而且查找速度基本和数据量大小无关，属于常数级别;而map的查找速度是log(n)级别。并不一定常数就比log(n) 小，hash还有hash函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑hash。但若你对内存使用特别严格， 希望程序尽可能少消耗内存，那么一定要小心，hash可能会让你陷入尴尬，特别是当你的hash对象特别多时，你就更无法控制了，而且 hash的构造速度较慢。</p>
<p>红黑树并不适应所有应用树的领域。如果数据基本上是静态的，那么让他们待在他们能够插入，并且不影响平衡的地方会具有更好的性能。如果数据完全是静态的，例如，做一个哈希表，性能可能会更好一些。</p>
<p>在实际的系统中，例如，需要使用动态规则的防火墙系统，使用红黑树而不是散列表被实践证明具有更好的伸缩性。Linux内核在管理vm_area_struct时就是采用了红黑树来维护内存块的。</p>
<p>红黑树通过扩展节点域可以在不改变时间复杂度的情况下得到结点的秩。<br>应用：C++的STL中，如set和map。Java中的TreeMap，HashMap，TreeSet，HashSet等，TreeSet（HashSet）底层就是通过TreeMap（HashMap）来实现的。</p>
<p><a href="https://blog.csdn.net/sun_tttt/article/details/65445754" target="_blank" rel="noopener">参考1</a><br><a href="http://blog.chinaunix.net/uid-26548237-id-3480169.html" target="_blank" rel="noopener">参考2</a><br><a href="https://blog.csdn.net/silangquan/article/details/18655795" target="_blank" rel="noopener">参考3</a></p>
<p>4.Trie树：又叫单词查找树，是一种哈希树的变种。典型应用是统计和排序大量的字符串（但又不仅限于字符串），经常被搜索引擎用于文本词频统计。可以最大限度地减少无谓的字符串比较，查询效率比哈希表高。核心思想是用空间换时间。<br>基本性质：</p>
<ul>
<li>根节点不包含字符，除根节点以外每个节点只包含一个字符。</li>
<li>从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符串不相同。</li>
<li>如果字符的种数为n，则每个结点的出度为n，这也是空间换时间的体现，浪费了很多的空间。</li>
<li>插入查找的复杂度为O(n)，n为字符串长度。</li>
</ul>
<p>基本思想：<br>插入过程:对于一个单词，从根开始，沿着单词的各个字母所对应的树中的节点分支向下走，直到单词遍历完，将最后的节点标记为红色，表示该单词已插入Trie树。</p>
<p>查询过程:同样的，从根开始按照单词的字母顺序向下遍历trie树，一旦发现某个节点标记不存在或者单词遍历完成而最后的节点未标记为红色，则表示该单词不存在，若最后的节点标记为红色，表示该单词存在。</p>
<p><a href="https://blog.csdn.net/gao1440156051/article/details/51357135" target="_blank" rel="noopener">参考</a></p>
<h1 id="图的基本概念是否知道？有向图？无向图？稀疏图？稠密图？完全图？简单图？连通图？连通分量？强连通图？强连通分量？图的入度和出度？"><a href="#图的基本概念是否知道？有向图？无向图？稀疏图？稠密图？完全图？简单图？连通图？连通分量？强连通图？强连通分量？图的入度和出度？" class="headerlink" title="图的基本概念是否知道？有向图？无向图？稀疏图？稠密图？完全图？简单图？连通图？连通分量？强连通图？强连通分量？图的入度和出度？"></a>图的基本概念是否知道？有向图？无向图？稀疏图？稠密图？完全图？简单图？连通图？连通分量？强连通图？强连通分量？图的入度和出度？</h1><p>答：</p>
<ul>
<li>简单图：无环。</li>
<li>连通图：无向图中任意两个顶点都连通。</li>
<li>连通分量：无向图中的极大连通子图。</li>
<li>强连通图：有向图中任意两个顶点都连通。</li>
<li>强连通分量：有向图中的极大连通子图。</li>
</ul>
<h1 id="图的表示有哪几种方式？"><a href="#图的表示有哪几种方式？" class="headerlink" title="图的表示有哪几种方式？"></a>图的表示有哪几种方式？</h1><p>答：</p>
<ol>
<li>邻接矩阵：适用于较小或中等规模的图，因为需要V*V的空间。</li>
<li>边的数组：自定义Edge类，包括边的两个端点的编号。实现简单，但是在求每个点的邻接点时较为困难。</li>
<li>邻接表数组：较为常用，使用一个以顶点为索引的数组，数组每个元素都是和该顶点相邻的顶点列表，这种数组占空间相对于邻接矩阵少了很多，并且能很好的找到某个给定点的所有邻接点。</li>
</ol>
<p><a href="https://blog.csdn.net/ntt5667781/article/details/52743342" target="_blank" rel="noopener">参考</a></p>
<h1 id="图的遍历方式有哪几种？各自有什么异同？分别在什么时候使用？"><a href="#图的遍历方式有哪几种？各自有什么异同？分别在什么时候使用？" class="headerlink" title="图的遍历方式有哪几种？各自有什么异同？分别在什么时候使用？"></a>图的遍历方式有哪几种？各自有什么异同？分别在什么时候使用？</h1><p>答：遍历方式：</p>
<ol>
<li>深度优先搜索DFS：这是一种典型的递归算法用来搜索图（遍历所有的顶点）。从图的某个顶点i开始，将顶点i标记为已访问顶点，并将访问顶点i的邻接列表中没有被标记的顶点j，将顶点j标记为已访问，并在访问顶点j的邻接列表中未被标记的顶点k依次深度遍历下去，直到某个点的所有邻接列表中的点都被标记为已访问后，返回上层。重复以上过程直到图中的所有顶点都被标记为已访问。<br>深度优先遍历和树的先序访问非常类似，尽可能深的去访问节点。<br>实现分为递归和非递归版本，后者借助于栈来实现。</li>
<li>广度优先搜索BFS：使用一个队列来保存所有已经被标记过的但是其邻接点还未被检查过的顶点，现将顶点加入队列中，然后重复下面的操作，直至队列为空：<br>1）取队列中的下一个顶点v并标记它<br>2）将与v相邻的所有的未被标记的顶点加入队列中。<br>广度优先遍历类似于树的按层遍历。</li>
</ol>
<p>DFS和BFS的比较：</p>
<ol>
<li>这两种算法每次都扩展一个节点的所有子节点，而不同的是，深度搜索下一次扩展的是本次扩展出来的子节点中的一个，而广度搜索扩展的则是本次扩展的节点的兄弟节点。</li>
<li>DFS可以迅速的找到一个解，然后利用这个解进行剪枝，而BFS可找到最优解。</li>
</ol>
<p><a href="https://blog.csdn.net/ntt5667781/article/details/52743342" target="_blank" rel="noopener">参考</a></p>
<h1 id="如何统计图中连通分量的数量？"><a href="#如何统计图中连通分量的数量？" class="headerlink" title="如何统计图中连通分量的数量？"></a>如何统计图中连通分量的数量？</h1><p>答：利用深度优先搜索DFS。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">        int V = 6;//图的顶点数</span><br><span class="line">        List&lt;Diijkstra.Edge&gt;[] edges = new List[V];</span><br><span class="line">        for (int i = 0;i &lt; V;i++) edges[i] = new ArrayList&lt;Diijkstra.Edge&gt;();</span><br><span class="line">        //edges[0].add(new Diijkstra.Edge(0,1,1));</span><br><span class="line">        edges[0].add(new Diijkstra.Edge(0,2,2));</span><br><span class="line">        edges[1].add(new Diijkstra.Edge(1,3,3));edges[1].add(new Diijkstra.Edge(1,4,4));</span><br><span class="line">        //edges[2].add(new Diijkstra.Edge(2,4,5));</span><br><span class="line">        edges[3].add(new Diijkstra.Edge(3,5,6));</span><br><span class="line">        edges[4].add(new Diijkstra.Edge(4,5,7));//图的边</span><br><span class="line"></span><br><span class="line">        int count = 0;</span><br><span class="line">        boolean[] flag = new boolean[V];</span><br><span class="line">        for (int i = 0;i &lt; V;i++)&#123;</span><br><span class="line">            if(!flag[i])&#123;</span><br><span class="line">                dfs(i, flag, edges);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void dfs(int s, boolean[] flag, List&lt;Diijkstra.Edge&gt;[] edegs)&#123;</span><br><span class="line">        flag[s] = true;</span><br><span class="line">        for (Diijkstra.Edge e : edegs[s])&#123;</span><br><span class="line">            int end = e.getEnd(s);</span><br><span class="line">            if(!flag[end]) dfs(end, flag, edegs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/ntt5667781/article/details/52743342" target="_blank" rel="noopener">参考</a></p>
<h1 id="如何检测图中是否有环？"><a href="#如何检测图中是否有环？" class="headerlink" title="如何检测图中是否有环？"></a>如何检测图中是否有环？</h1><p>答：利用深度优先搜索。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private static boolean hasCycle = false;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int V = 6;//图的顶点数</span><br><span class="line">        List&lt;Diijkstra.Edge&gt;[] edges = new List[V];</span><br><span class="line">        for (int i = 0;i &lt; V;i++) edges[i] = new ArrayList&lt;Diijkstra.Edge&gt;();</span><br><span class="line">        edges[0].add(new Diijkstra.Edge(0,1,1));edges[0].add(new Diijkstra.Edge(0,2,2));</span><br><span class="line">        edges[1].add(new Diijkstra.Edge(1,3,3));edges[1].add(new Diijkstra.Edge(1,4,4));</span><br><span class="line">        edges[2].add(new Diijkstra.Edge(2,4,5));</span><br><span class="line">        edges[2].add(new Diijkstra.Edge(2,0,5));</span><br><span class="line">        edges[3].add(new Diijkstra.Edge(3,5,6));</span><br><span class="line">        edges[4].add(new Diijkstra.Edge(4,2,7));</span><br><span class="line">        //edges[4].add(new Diijkstra.Edge(4,5,7));//图的边</span><br><span class="line"></span><br><span class="line">        boolean[] flag = new boolean[V];</span><br><span class="line">        for (int i = 0;i &lt; V;i++)&#123;</span><br><span class="line">            if(!flag[i]) dfs(i, i, flag, edges);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(hasCycle);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void dfs(int s, int initial, boolean[] flag, List&lt;Diijkstra.Edge&gt;[] edges)&#123;</span><br><span class="line">        flag[s] = true;</span><br><span class="line">        for (Diijkstra.Edge e : edges[s])&#123;</span><br><span class="line">            int end = e.getEnd(s);</span><br><span class="line">            if(!flag[end]) dfs(end, initial, flag, edges);</span><br><span class="line">            else&#123;</span><br><span class="line">                if(end == initial)&#123;</span><br><span class="line">                    hasCycle = true;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://blog.csdn.net/ntt5667781/article/details/52743342" target="_blank" rel="noopener">参考</a></p>
<h1 id="如何解决二分图判断（双色问题）？"><a href="#如何解决二分图判断（双色问题）？" class="headerlink" title="如何解决二分图判断（双色问题）？"></a>如何解决二分图判断（双色问题）？</h1><p>答：利用深度优先搜索。</p>
<p><a href="https://blog.csdn.net/ntt5667781/article/details/52743342" target="_blank" rel="noopener">参考</a></p>
<h1 id="能否写出图的拓扑排序算法？"><a href="#能否写出图的拓扑排序算法？" class="headerlink" title="能否写出图的拓扑排序算法？"></a>能否写出图的拓扑排序算法？</h1><p>答：给定一幅有向图，给所有的结点排序，排序后使得有向边均从排在前面的结点元素指向排在后面的结点元素（或者说明这个有向图不能进行拓扑排序）。在对一个有向图进行拓扑排序的时候，必须保证它是无环的有向图，因为有环的图不能做到拓扑有序。<br>其实对于标准的深度优先搜索算法添加一行代码就能实现这个问题。在使用深度优先搜索的时候，正好只会访问每个结点一次，如果将dfs()访问的结点存储在一个数据结构中，然后遍历这个结构就可以访问图中所有结点，遍历的顺序取决于这个数据结构的性质以及是在递归前还是递归后保存</p>
<ul>
<li>前序：在递归前将顶点放入队列中</li>
<li>后序：在递归调用之后将顶点放入队列中</li>
<li>逆后序：在递归调用之后将顶点压入栈中。</li>
</ul>
<p>一幅有序无环图的拓扑排序就是所有顶点的逆后序排列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static List&lt;Integer&gt; pre = new ArrayList&lt;Integer&gt;();</span><br><span class="line">static List&lt;Integer&gt; post = new ArrayList&lt;Integer&gt;();</span><br><span class="line">static Deque&lt;Integer&gt; reversepost = new ArrayDeque&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    int V = 6;//图的顶点数</span><br><span class="line">    List&lt;Diijkstra.Edge&gt;[] edges = new List[V];</span><br><span class="line">    for (int i = 0;i &lt; V;i++) edges[i] = new ArrayList&lt;Diijkstra.Edge&gt;();</span><br><span class="line">    edges[0].add(new Diijkstra.Edge(0,1,1));edges[0].add(new Diijkstra.Edge(0,2,2));</span><br><span class="line">    edges[1].add(new Diijkstra.Edge(1,3,3));edges[1].add(new Diijkstra.Edge(1,4,4));</span><br><span class="line">    edges[2].add(new Diijkstra.Edge(2,4,5));</span><br><span class="line">    edges[3].add(new Diijkstra.Edge(3,5,6));</span><br><span class="line">    edges[4].add(new Diijkstra.Edge(4,5,7));//图的边</span><br><span class="line"></span><br><span class="line">    boolean[] flag = new boolean[V];</span><br><span class="line">    for (int i = 0;i &lt; V;i++) if (!flag[i]) dfs(i, flag, edges);</span><br><span class="line"></span><br><span class="line">    for (int x : pre) System.out.print(x + &quot; &quot;);</span><br><span class="line">    System.out.println();</span><br><span class="line">    for (int x : post) System.out.print(x + &quot; &quot;);</span><br><span class="line">    System.out.println();</span><br><span class="line">    while (reversepost.size() &gt; 0)&#123;</span><br><span class="line">        System.out.print(reversepost.removeLast() + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void dfs(int s, boolean[] flag, List&lt;Diijkstra.Edge&gt;[] edges)&#123;</span><br><span class="line">    pre.add(s);</span><br><span class="line">    flag[s] = true;</span><br><span class="line">    for (Diijkstra.Edge e : edges[s])&#123;</span><br><span class="line">        int end = e.getEnd(s);</span><br><span class="line">        if(!flag[end])&#123;</span><br><span class="line">            dfs(end, flag, edges);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post.add(s);</span><br><span class="line">    reversepost.addLast(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://blog.csdn.net/ntt5667781/article/details/52743342" target="_blank" rel="noopener">参考</a></p>
<h1 id="求解图的最小生成树有哪些前提？所有最小生成树算法的基础是什么，使用的是哪种算法策略，dp还是贪心？有哪几种实现算法？"><a href="#求解图的最小生成树有哪些前提？所有最小生成树算法的基础是什么，使用的是哪种算法策略，dp还是贪心？有哪几种实现算法？" class="headerlink" title="求解图的最小生成树有哪些前提？所有最小生成树算法的基础是什么，使用的是哪种算法策略，dp还是贪心？有哪几种实现算法？"></a>求解图的最小生成树有哪些前提？所有最小生成树算法的基础是什么，使用的是哪种算法策略，dp还是贪心？有哪几种实现算法？</h1><p>答：前提：</p>
<ol>
<li>只考虑连通图。</li>
<li>边的权重可以是任何数。</li>
<li>所有边的权重各不相同（如果存在权重相同的边，则最小生成树不唯一）。</li>
</ol>
<p>所有最小生成树算法的基础都是切分定理：将加权图中的所有顶点分成两个集合（两个非空且不重合的集合），检查横跨两个集合的所有边（这种边被称为横切边:一条连接两个不属于同一集合顶点的边），并识别那条边是否应该属于图的最小生成树。在一幅加权图中，给定任意的划分，它的横切边中权值最小者必然属于最小生成树。（证明：使用反证法，假设e为权值最小的横切边，T为图的最小生成树。如果T中不包含e,那么必然包含一条横切边f，将e边加入最小生成树中，形成了一个环，包含e, f边，那么将f从环中删去，生成一个新的生成树T’显然，新的生成树比原来的最小生成树更小，这与已知矛盾）。</p>
<p>所有求解最小生成树的算法都是使用的贪心策略（根据切分定理，每次选择一种划分，使得所有的横切边都没有被标记，那么选择权值最小的横切边，直至选择了V-1条边为止。只不过对于不同的算法所使用的切分方法和判断权值最小的横切边的方式有所不同。）</p>
<p>实现算法：<br>1.Prim算法：最开始树中只有一个顶点，每次为生长中的树添加一个边，直至添加了V-1条边为止，每次添加的边都是树中的顶点和非树中的顶点所划分的两个集合的横切边中最小的边。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    int V = 6;//图的顶点数</span><br><span class="line">    List&lt;Edge&gt;[] edges = new List[V];</span><br><span class="line">    for (int i = 0;i &lt; V;i++) edges[i] = new ArrayList&lt;Edge&gt;();</span><br><span class="line">    edges[0].add(new Edge(0,1,1));edges[0].add(new Edge(0,2,2));edges[1].add(new Edge(1,3,3));edges[1].add(new Edge(1,4,4));edges[2].add(new Edge(2,4,5));edges[3].add(new Edge(3,5,6));edges[4].add(new Edge(4,5,7));</span><br><span class="line">    boolean[] isInTree = new boolean[V];//标识节点是否已经在最小生成树中</span><br><span class="line">    for (int i = 0;i &lt; V;i++) isInTree[i] = false;</span><br><span class="line">    List&lt;Edge&gt; mst = new ArrayList&lt;Edge&gt;();//V个节点则mst有V-1条边</span><br><span class="line">    List&lt;Edge&gt; minQueue = new ArrayList&lt;Edge&gt;();//优先队列</span><br><span class="line">    visit(0, isInTree, edges, minQueue);</span><br><span class="line">    while (minQueue.size() &gt; 0)&#123;</span><br><span class="line">        //取出最小的边</span><br><span class="line">        int min = Integer.MAX_VALUE;</span><br><span class="line">        Edge minEdge = null;</span><br><span class="line">        for (Edge e : minQueue)&#123;</span><br><span class="line">            if(e.getWeight() &lt; min)&#123;</span><br><span class="line">                min = e.getWeight();</span><br><span class="line">                minEdge = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        minQueue.remove(minEdge);//删除权重最小的边</span><br><span class="line">        int start = minEdge.getStart(), end = minEdge.getEnd(start);</span><br><span class="line">        if(isInTree[start] &amp;&amp; isInTree[end]) continue;</span><br><span class="line">        mst.add(minEdge);</span><br><span class="line">        if (!isInTree[start]) visit(start, isInTree, edges, minQueue);</span><br><span class="line">        else if(!isInTree[end]) visit(end, isInTree, edges, minQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //打印所有边</span><br><span class="line">    for (Edge edge : mst)</span><br><span class="line">        System.out.println(edge.getStart() + &quot;:&quot; + edge.getWeight());</span><br><span class="line">&#125;</span><br><span class="line">/**加入一个节点到最小生成树中，并将该节点的边加入优先队列中*/</span><br><span class="line">private static void visit(int start, boolean[] isInTree, List&lt;Edge&gt;[] edges, List&lt;Edge&gt; minQueue)&#123;</span><br><span class="line">    isInTree[start] = true;</span><br><span class="line">    for (Edge edge : (edges[start]))&#123;</span><br><span class="line">        if(!isInTree[edge.getEnd(start)]) minQueue.add(edge);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**定义图的边类*/</span><br><span class="line">static class Edge&#123;</span><br><span class="line">    private int start;//顶点</span><br><span class="line">    private int end;//末点</span><br><span class="line">    private int weight;//边的权重</span><br><span class="line">    public Edge(int start, int end, int weight)&#123;</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.end = end;</span><br><span class="line">        this.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    /**根据顶点获取末点*/</span><br><span class="line">    public int getEnd(int start)&#123;</span><br><span class="line">        if(start == this.start) return this.end;</span><br><span class="line">        else return start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getStart()&#123;return this.start;&#125;</span><br><span class="line">    public int getWeight()&#123;return this.weight;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.Kruskal算法：按照边的权重顺序来处理它们，依次将当前权值最小的边加入生成树的边中（加入的边不能和已经加入的边构成环）直至加入了V-1条边。在整个过程中，加入的边组成的森林随着新加入的边渐渐合成一棵树。<br>使用一个优先队列来将所有的边（也就是为所有边按照权值排序），然后再使用union-find数据结构识别新加入的边是否会和已有的树中的边形成环（由于这是在动态处理中识别环是否存在，这里使用union-find（由于深度优先算法需要预处理整个图，在这里不是很适用），最后用一个队列或者别的数据结构来保存最小生成树的所有边。</p>
<p><a href="https://blog.csdn.net/ntt5667781/article/details/52743342" target="_blank" rel="noopener">参考</a></p>
<h1 id="求解最短路径算法有哪几种？分别有什么特点？各自的时间复杂度和空间复杂度是多少？"><a href="#求解最短路径算法有哪几种？分别有什么特点？各自的时间复杂度和空间复杂度是多少？" class="headerlink" title="求解最短路径算法有哪几种？分别有什么特点？各自的时间复杂度和空间复杂度是多少？"></a>求解最短路径算法有哪几种？分别有什么特点？各自的时间复杂度和空间复杂度是多少？</h1><p>答：<br>1.深度或广度优先算法：解决单源最短路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private static void dfs(int curNode, int curDis, List&lt;Diijkstra.Edge&gt;[] edges, boolean[] flag)&#123;</span><br><span class="line">    if(curDis &gt; minDis) return;//如果当前距离已经大于最短距离，剪枝</span><br><span class="line">    if(curNode == end)&#123;//递归边界</span><br><span class="line">        minDis = Math.min(minDis, curDis);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        for (Diijkstra.Edge e : edges[curNode])&#123;</span><br><span class="line">            int endT = e.getEnd(curNode);</span><br><span class="line">            if(!flag[endT])&#123;</span><br><span class="line">                flag[endT] = true;</span><br><span class="line">                dfs(endT, curDis + e.getWeight(), edges, flag);</span><br><span class="line">                flag[endT] = false;//note恢复flag为没有访问过</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://blog.csdn.net/qibofang/article/details/51594673" target="_blank" rel="noopener">参考</a></p>
<p>2.Dijkstra算法：该算法采用了的思想和在求最小生成树时候使用的prim算法类似的思想，首先将distTo[s]设置为0，distTo的其他元素设置为正无穷大，然后将distTo中最小的非树顶点放松并加入到树中，如此这般，直至所有顶点都在树中，或者所有非树顶点的distTo都无穷大。能解决边权值非负的加权的有向图的最短路径问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    int V = 6;//图的顶点数</span><br><span class="line">    List&lt;Edge&gt;[] edges = new List[V];</span><br><span class="line">    for (int i = 0;i &lt; V;i++) edges[i] = new ArrayList&lt;Edge&gt;();</span><br><span class="line">    edges[0].add(new Edge(0,1,1));edges[0].add(new Edge(0,2,2));</span><br><span class="line">    edges[1].add(new Edge(1,3,3));edges[1].add(new Edge(1,4,4));</span><br><span class="line">    edges[2].add(new Edge(2,4,5));</span><br><span class="line">    edges[3].add(new Edge(3,5,6));</span><br><span class="line">    edges[4].add(new Edge(4,5,7));//图的边</span><br><span class="line">    int[] disTo = new int[V];//顶点到所有点的最短距离</span><br><span class="line">    for (int i = 0;i &lt; V;i++) disTo[i] = Integer.MAX_VALUE;</span><br><span class="line">    disTo[0] = 0;</span><br><span class="line">    Map&lt;Integer, Integer&gt; minQueue = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    minQueue.put(0, 0);</span><br><span class="line">    while (minQueue.size() &gt; 0)&#123;</span><br><span class="line">        Integer minV = null;</span><br><span class="line">        int minDis = Integer.MAX_VALUE;</span><br><span class="line">        Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; set = minQueue.entrySet();</span><br><span class="line">        for (Map.Entry&lt;Integer, Integer&gt; entry : set)&#123;</span><br><span class="line">            if(entry.getValue() &lt; minDis)&#123;</span><br><span class="line">                minV = entry.getKey();</span><br><span class="line">                minDis = entry.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        minQueue.remove(minV);</span><br><span class="line">        relax(minV, edges, disTo, minQueue);//边的松弛操作</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int x : disTo) System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">/**边的松弛操作*/</span><br><span class="line">private static void relax(int start, List&lt;Edge&gt;[] edges,</span><br><span class="line">                          int[] disTo, Map&lt;Integer, Integer&gt; minQueue)&#123;</span><br><span class="line">    for (Edge e : edges[start])&#123;</span><br><span class="line">        int end = e.getEnd(start);</span><br><span class="line">        if(disTo[end] &gt; disTo[start] + e.getWeight())&#123;</span><br><span class="line">            disTo[end] = disTo[start] + e.getWeight();</span><br><span class="line">            minQueue.put(end, disTo[end]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**定义图的边类*/</span><br><span class="line">static class Edge&#123;</span><br><span class="line">    private int start;//顶点</span><br><span class="line">    private int end;//末点</span><br><span class="line">    private int weight;//边的权重</span><br><span class="line">    public Edge(int start, int end, int weight)&#123;</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.end = end;</span><br><span class="line">        this.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    /**根据顶点获取末点*/</span><br><span class="line">    public int getEnd(int start)&#123;</span><br><span class="line">        if(start == this.start) return this.end;</span><br><span class="line">        else return start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getStart()&#123;return this.start;&#125;</span><br><span class="line">    public int getWeight()&#123;return this.weight;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.无环加权有向图中的最短路径算法：对比Dijstra算法来说，对于无环加权有向图的最短路径有个好的改进算法，该算法：</p>
<ul>
<li>能够在线性时间内解决单点最短路径；</li>
<li>能够处理权值为负的边</li>
<li>能够解决相关问题（譬如，最长路径求解）</li>
</ul>
<p>这些都是在无环有向图的拓扑排序算法的简单扩展，特别的是，将顶点放松和拓扑排序结合起来就能得到这种解决无环加权有向图的最短路径的简单算法。</p>
<p>首先将distTo[s]初始化为0，其他distTo数组元素初始化正无穷大，然后按照拓扑排序来一个个放松顶点。（这种方法能在于V+E成正比的时间内解决无环加权有向图的最短路径问题）</p>
<p>对于无环问题来说，这种拓扑排序和放松相结合的算法，大大简化了问题的判断，而且这种算法和边的权值的正负无关。但是只能适用于无环结构（有环结构不能进行拓扑排序）。</p>
<p>4.Floyd弗洛伊德算法：解决多源最短路径。时间复杂度O(n^3),空间复杂度O(n^2)。基本思想：最开始只允许经过1号顶点进行中转，接下来只允许经过1号和2号顶点进行中转……允许经过1~n号所有顶点进行中转，来不断动态更新任意两点之间的最短路程。即求从i号顶点到j号顶点只经过前k号点的最短路程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    int V = 6;//图的顶点数</span><br><span class="line">    List&lt;Diijkstra.Edge&gt;[] edges = new List[V];</span><br><span class="line">    for (int i = 0;i &lt; V;i++) edges[i] = new ArrayList&lt;Diijkstra.Edge&gt;();</span><br><span class="line">    edges[0].add(new Diijkstra.Edge(0,1,1));edges[0].add(new Diijkstra.Edge(0,2,2));</span><br><span class="line">    edges[1].add(new Diijkstra.Edge(1,3,3));edges[1].add(new Diijkstra.Edge(1,4,4));</span><br><span class="line">    edges[2].add(new Diijkstra.Edge(2,4,5));</span><br><span class="line">    edges[3].add(new Diijkstra.Edge(3,5,6));</span><br><span class="line">    edges[4].add(new Diijkstra.Edge(4,5,7));//图的边</span><br><span class="line"></span><br><span class="line">    int[][] floyd = new int[V][V];//floyd邻接矩阵</span><br><span class="line">    for (int i = 0;i &lt; V;i++)&#123;</span><br><span class="line">        for (int j = 0;j &lt; V;j++)&#123;</span><br><span class="line">            floyd[i][j] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        floyd[i][i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for (List&lt;Diijkstra.Edge&gt; list : edges)&#123;</span><br><span class="line">        for (Diijkstra.Edge e : list)&#123;</span><br><span class="line">            int start = e.getStart(), end = e.getEnd(start);</span><br><span class="line">            floyd[start][end] = e.getWeight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**floyd算法*/</span><br><span class="line">    for (int k = 0;k &lt; V;k++)&#123;//note k表示只允许经过前k个节点</span><br><span class="line">        for (int i = 0;i &lt; V;i++)&#123;</span><br><span class="line">            for (int j = 0;j &lt; V;j++)&#123;</span><br><span class="line">                if(floyd[i][k] &lt; Integer.MAX_VALUE &amp;&amp;</span><br><span class="line">                        floyd[k][j] &lt; Integer.MAX_VALUE &amp;&amp;</span><br><span class="line">                        floyd[i][j] &gt; floyd[i][k] + floyd[k][j])&#123;</span><br><span class="line">                    floyd[i][j] = floyd[i][k] + floyd[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int s = 1, e = 5;</span><br><span class="line">    System.out.println(floyd[s][e]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.一般加权有向图中的最短路径算法（BellmanFord算法）：解决负权边，解决单源最短路径。时间复杂度O(n*m)，空间复杂度O(m)。主要思想：对所有的边进行n-1轮松弛操作，因为在一个含有n个顶点的图中，任意两点之间的最短路径最多包含n-1边。换句话说，第1轮在对所有的边进行松弛后，得到的是从1号顶点只能经过一条边到达其余各定点的最短路径长度。第2轮在对所有的边进行松弛后，得到的是从1号顶点只能经过两条边到达其余各定点的最短路径长度，…..<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    int V = 6;//图的顶点数</span><br><span class="line">    List&lt;Diijkstra.Edge&gt;[] edges = new List[V];</span><br><span class="line">    for (int i = 0;i &lt; V;i++) edges[i] = new ArrayList&lt;Diijkstra.Edge&gt;();</span><br><span class="line">    edges[0].add(new Diijkstra.Edge(0,1,1));edges[0].add(new Diijkstra.Edge(0,2,2));</span><br><span class="line">    edges[1].add(new Diijkstra.Edge(1,3,3));edges[1].add(new Diijkstra.Edge(1,4,4));</span><br><span class="line">    edges[2].add(new Diijkstra.Edge(2,4,5));</span><br><span class="line">    edges[3].add(new Diijkstra.Edge(3,5,6));</span><br><span class="line">    edges[4].add(new Diijkstra.Edge(4,5,7));//图的边</span><br><span class="line"></span><br><span class="line">    int[] minDis = new int[V];//保存最短距离</span><br><span class="line">    for (int i = 0;i &lt; V;i++) minDis[i] = Integer.MAX_VALUE;</span><br><span class="line">    minDis[0] = 0;</span><br><span class="line">    for (int k = 1;k &lt;= V - 1;k++)&#123;//进行V-1轮对所有边的松弛</span><br><span class="line">        for (List&lt;Diijkstra.Edge&gt; list : edges)&#123;</span><br><span class="line">            for (Diijkstra.Edge e : list)&#123;</span><br><span class="line">                int start = e.getStart(), end = e.getEnd(start);</span><br><span class="line">                if (minDis[end] &gt; minDis[start] + e.getWeight())&#123;</span><br><span class="line">                    minDis[end] = minDis[start] + e.getWeight();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**检测负权回路*/</span><br><span class="line">    boolean flag = false;</span><br><span class="line">    for (List&lt;Diijkstra.Edge&gt; list : edges)&#123;</span><br><span class="line">        for (Diijkstra.Edge e : list)&#123;</span><br><span class="line">            int start = e.getStart(), end = e.getEnd(start);</span><br><span class="line">            if (minDis[end] &gt; minDis[start] + e.getWeight())&#123;</span><br><span class="line">                flag = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int x : minDis) System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度：</p>
<ol>
<li>Dijkstra：适用于权值为非负的图的单源最短路径，用斐波那契堆的复杂度O(E+VlgV)</li>
<li>BellmanFord：适用于权值有负值的图的单源最短路径，并且能够检测负圈，复杂度O(VE)</li>
<li>SPFA：适用于权值有负值，且没有负圈的图的单源最短路径，论文中的复杂度O(kE)，k为每个节点进入Queue的次数，且k一般&lt;=2，但此处的复杂度证明是有问题的，其实SPFA的最坏情况应该是O(VE).</li>
<li>Floyd：每对节点之间的最短路径。复杂度为O(n^3)</li>
</ol>
<p>结论：</p>
<ol>
<li>当权值为非负时，用Dijkstra。</li>
<li>当权值有负值，且没有负圈，则用SPFA，SPFA能检测负圈，但是不能输出负圈。</li>
<li>当权值有负值，而且可能存在负圈，则用BellmanFord，能够检测并输出负圈。</li>
<li>SPFA检测负环：当存在一个点入队大于等于V次，则有负环，后面有证明。</li>
</ol>
<p><a href="https://blog.csdn.net/ntt5667781/article/details/52743342" target="_blank" rel="noopener">参考1</a><br><a href="https://blog.csdn.net/qibofang/article/details/51594673" target="_blank" rel="noopener">参考2</a><br><a href="https://blog.csdn.net/xiazdong/article/details/8193680" target="_blank" rel="noopener">参考3</a></p>



                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/techlife/Java面试之数据库/" data-toggle="tooltip" data-placement="top" title="Java面试之数据库">&larr; 上一篇</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/techlife/Java面试之设计模式/" data-toggle="tooltip" data-placement="top" title="Java面试之设计模式">下一篇 &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!--打赏-->
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                <!--分享-->
                <br>

                <!-- require APlayer -->
                

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                
				
            </div>

            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#如何根据数据范围决定采用的算法的时间复杂度？"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">如何根据数据范围决定采用的算法的时间复杂度？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#尾递归的概念是什么？有什么好处？"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">尾递归的概念是什么？有什么好处？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#排序算法有哪些？每种算法的最好、最坏、平均时间复杂度？空间复杂度？是否稳定？是否就地？算法复杂度是否和初始排列有关？画出那张图？"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">排序算法有哪些？每种算法的最好、最坏、平均时间复杂度？空间复杂度？是否稳定？是否就地？算法复杂度是否和初始排列有关？画出那张图？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#能否写出每种排序算法？"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">能否写出每种排序算法？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#JDK中Arrays-sort-是如何实现的？"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">JDK中Arrays.sort()是如何实现的？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#常见的查找算法有哪些？速度怎么排？"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">常见的查找算法有哪些？速度怎么排？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#能否写出二分查找法？需要注意哪些点？二分查找有哪些变种？"><span class="toc-nav-number">7.</span> <span class="toc-nav-text">能否写出二分查找法？需要注意哪些点？二分查找有哪些变种？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#字符串KMP算法是否会写？关键思想是什么？实现步骤是什么？next数组的含义是什么？next数组怎么优化？为什么要优化？"><span class="toc-nav-number">8.</span> <span class="toc-nav-text">字符串KMP算法是否会写？关键思想是什么？实现步骤是什么？next数组的含义是什么？next数组怎么优化？为什么要优化？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#动态规划的经典问题有哪些？"><span class="toc-nav-number">9.</span> <span class="toc-nav-text">动态规划的经典问题有哪些？</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#硬币找零问题"><span class="toc-nav-number">9.1.</span> <span class="toc-nav-text">硬币找零问题</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#装配线调度问题？"><span class="toc-nav-number">9.2.</span> <span class="toc-nav-text">装配线调度问题？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#最长公共子序列问题？"><span class="toc-nav-number">9.3.</span> <span class="toc-nav-text">最长公共子序列问题？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#最长递增子序列问题？"><span class="toc-nav-number">9.4.</span> <span class="toc-nav-text">最长递增子序列问题？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#最大连续子序列和-积问题？"><span class="toc-nav-number">9.5.</span> <span class="toc-nav-text">最大连续子序列和/积问题？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#矩阵链乘问题"><span class="toc-nav-number">9.6.</span> <span class="toc-nav-text">矩阵链乘问题</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#0-1背包问题？"><span class="toc-nav-number">9.7.</span> <span class="toc-nav-text">0-1背包问题？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#有代价的最短路径问题？"><span class="toc-nav-number">9.8.</span> <span class="toc-nav-text">有代价的最短路径问题？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#筛素数法如何实现？关键思想是什么？"><span class="toc-nav-number">10.</span> <span class="toc-nav-text">筛素数法如何实现？关键思想是什么？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#位操作有哪些？"><span class="toc-nav-number">11.</span> <span class="toc-nav-text">位操作有哪些？</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#优先级怎么样？"><span class="toc-nav-number">11.1.</span> <span class="toc-nav-text">优先级怎么样？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#异或操作有什么特性？"><span class="toc-nav-number">11.2.</span> <span class="toc-nav-text">异或操作有什么特性？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#如何对一个整数在指定位置置0-1？"><span class="toc-nav-number">11.3.</span> <span class="toc-nav-text">如何对一个整数在指定位置置0/1？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#如何判断奇偶？"><span class="toc-nav-number">11.4.</span> <span class="toc-nav-text">如何判断奇偶？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#交换两个数如何实现？"><span class="toc-nav-number">11.5.</span> <span class="toc-nav-text">交换两个数如何实现？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#交换符号如何实现？"><span class="toc-nav-number">11.6.</span> <span class="toc-nav-text">交换符号如何实现？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#求绝对值如何实现？"><span class="toc-nav-number">11.7.</span> <span class="toc-nav-text">求绝对值如何实现？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#筛素数法如何使用位操作进行空间压缩？"><span class="toc-nav-number">11.8.</span> <span class="toc-nav-text">筛素数法如何使用位操作进行空间压缩？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#高低位交换如何实现？"><span class="toc-nav-number">11.9.</span> <span class="toc-nav-text">高低位交换如何实现？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#二进制逆序如何实现？"><span class="toc-nav-number">11.10.</span> <span class="toc-nav-text">二进制逆序如何实现？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#如何计算二进制中1的个数？"><span class="toc-nav-number">11.11.</span> <span class="toc-nav-text">如何计算二进制中1的个数？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#缺失的数字问题如何解决？"><span class="toc-nav-number">11.12.</span> <span class="toc-nav-text">缺失的数字问题如何解决？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#如何不使用四则运算计算两个数的和？"><span class="toc-nav-number">11.13.</span> <span class="toc-nav-text">如何不使用四则运算计算两个数的和？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#如何寻找最大的K个数？"><span class="toc-nav-number">12.</span> <span class="toc-nav-text">如何寻找最大的K个数？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#如何求解最大公约数？"><span class="toc-nav-number">13.</span> <span class="toc-nav-text">如何求解最大公约数？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#如何求解Fibonacci数列？"><span class="toc-nav-number">14.</span> <span class="toc-nav-text">如何求解Fibonacci数列？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#如何同时找出数组中的最大数和最小数？如何减少比较的次数？"><span class="toc-nav-number">15.</span> <span class="toc-nav-text">如何同时找出数组中的最大数和最小数？如何减少比较的次数？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#如何快速找到满足条件的两个数？"><span class="toc-nav-number">16.</span> <span class="toc-nav-text">如何快速找到满足条件的两个数？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#如何求解数组的子数组之和的最大值？如何让你的算法从O-n-2-到O-n-lgn-再到O-n-一步步优化？"><span class="toc-nav-number">17.</span> <span class="toc-nav-text">如何求解数组的子数组之和的最大值？如何让你的算法从O(n^2)到O(n*lgn)再到O(n)一步步优化？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#如何计算字符串的相似度？"><span class="toc-nav-number">18.</span> <span class="toc-nav-text">如何计算字符串的相似度？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#如何从无头单链表中删除节点？"><span class="toc-nav-number">19.</span> <span class="toc-nav-text">如何从无头单链表中删除节点？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#如何判断两个链表是否相交？"><span class="toc-nav-number">20.</span> <span class="toc-nav-text">如何判断两个链表是否相交？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#如何判断一个链表是否有环？"><span class="toc-nav-number">21.</span> <span class="toc-nav-text">如何判断一个链表是否有环？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#如何使从队列中取最大值操作的效率尽可能高？"><span class="toc-nav-number">22.</span> <span class="toc-nav-text">如何使从队列中取最大值操作的效率尽可能高？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#树的基本概念是否都知道？满二叉树？完全二叉树？"><span class="toc-nav-number">23.</span> <span class="toc-nav-text">树的基本概念是否都知道？满二叉树？完全二叉树？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#二叉树的基本性质有哪些？关于二叉树的各种计算是否都会？二叉树的各种属性？计算树的高度？计算树的（各层-总）节点树？"><span class="toc-nav-number">24.</span> <span class="toc-nav-text">二叉树的基本性质有哪些？关于二叉树的各种计算是否都会？二叉树的各种属性？计算树的高度？计算树的（各层/总）节点树？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#能否写出二叉树的先序、中序和后序遍历的算法？"><span class="toc-nav-number">25.</span> <span class="toc-nav-text">能否写出二叉树的先序、中序和后序遍历的算法？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#能否写出二叉树的深度优先和广度优先算法？"><span class="toc-nav-number">26.</span> <span class="toc-nav-text">能否写出二叉树的深度优先和广度优先算法？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#如何计算二叉树中节点的最大距离？"><span class="toc-nav-number">27.</span> <span class="toc-nav-text">如何计算二叉树中节点的最大距离？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#如何根据二叉树的先序和中序遍历结果重建二叉树？"><span class="toc-nav-number">28.</span> <span class="toc-nav-text">如何根据二叉树的先序和中序遍历结果重建二叉树？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#如何分层遍历二叉树？"><span class="toc-nav-number">29.</span> <span class="toc-nav-text">如何分层遍历二叉树？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#是否了解二叉查找树，平衡二叉树（AVL树），线索二叉树，哈夫曼树，红黑树，和Trie树的基本概念？各有哪些应用？"><span class="toc-nav-number">30.</span> <span class="toc-nav-text">是否了解二叉查找树，平衡二叉树（AVL树），线索二叉树，哈夫曼树，红黑树，和Trie树的基本概念？各有哪些应用？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#图的基本概念是否知道？有向图？无向图？稀疏图？稠密图？完全图？简单图？连通图？连通分量？强连通图？强连通分量？图的入度和出度？"><span class="toc-nav-number">31.</span> <span class="toc-nav-text">图的基本概念是否知道？有向图？无向图？稀疏图？稠密图？完全图？简单图？连通图？连通分量？强连通图？强连通分量？图的入度和出度？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#图的表示有哪几种方式？"><span class="toc-nav-number">32.</span> <span class="toc-nav-text">图的表示有哪几种方式？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#图的遍历方式有哪几种？各自有什么异同？分别在什么时候使用？"><span class="toc-nav-number">33.</span> <span class="toc-nav-text">图的遍历方式有哪几种？各自有什么异同？分别在什么时候使用？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#如何统计图中连通分量的数量？"><span class="toc-nav-number">34.</span> <span class="toc-nav-text">如何统计图中连通分量的数量？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#如何检测图中是否有环？"><span class="toc-nav-number">35.</span> <span class="toc-nav-text">如何检测图中是否有环？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#如何解决二分图判断（双色问题）？"><span class="toc-nav-number">36.</span> <span class="toc-nav-text">如何解决二分图判断（双色问题）？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#能否写出图的拓扑排序算法？"><span class="toc-nav-number">37.</span> <span class="toc-nav-text">能否写出图的拓扑排序算法？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#求解图的最小生成树有哪些前提？所有最小生成树算法的基础是什么，使用的是哪种算法策略，dp还是贪心？有哪几种实现算法？"><span class="toc-nav-number">38.</span> <span class="toc-nav-text">求解图的最小生成树有哪些前提？所有最小生成树算法的基础是什么，使用的是哪种算法策略，dp还是贪心？有哪几种实现算法？</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#求解最短路径算法有哪几种？分别有什么特点？各自的时间复杂度和空间复杂度是多少？"><span class="toc-nav-number">39.</span> <span class="toc-nav-text">求解最短路径算法有哪几种？分别有什么特点？各自的时间复杂度和空间复杂度是多少？</span></a></li></ol>
        
        </div>
      </aside>
    


            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">标签云</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Java" title="Java">Java</a>
                        
                          <a class="tag" href="/tags/#面试" title="面试">面试</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://coolshell.cn" target="_blank">coolshell</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>






<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/kid1994">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 剑知 2020 
                    <br>
                    Powered by <a href="http://www.hexo.io">Hexo</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Theme by <a href="https://github.com/kinggozhang/hexo-theme-ace">ACE</a> 
					
					
					<i class="fa fa-eye" id="leancounter"></i>
					
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

   <script src="https://cdn.staticfile.org/jquery/2.2.4/jquery.min.js"></script>



<!-- Bootstrap Core JavaScript -->

   <script src="https://cdn.staticfile.org/twitter-bootstrap/3.4.1/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


	<script src="/js/particles.js"></script>
	<script src="/js/particles_config.js"></script>



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://kid1994.github.io/techlife/Java面试之数据结构和算法/index.html/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="http://kid1994.github.io/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
